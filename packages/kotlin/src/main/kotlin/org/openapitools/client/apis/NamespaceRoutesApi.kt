/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountsNamesDTO
import org.openapitools.client.models.Addresses
import org.openapitools.client.models.AliasTypeEnum
import org.openapitools.client.models.MerkleStateInfoDTO
import org.openapitools.client.models.ModelError
import org.openapitools.client.models.MosaicIds
import org.openapitools.client.models.MosaicsNamesDTO
import org.openapitools.client.models.NamespaceIds
import org.openapitools.client.models.NamespaceInfoDTO
import org.openapitools.client.models.NamespaceNameDTO
import org.openapitools.client.models.NamespacePage
import org.openapitools.client.models.NamespaceRegistrationTypeEnum
import org.openapitools.client.models.Order

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class NamespaceRoutesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3000")
        }
    }

    /**
     * Get readable names for a set of accountIds
     * Returns friendly names for accounts.
     * @param addresses 
     * @return AccountsNamesDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountsNames(addresses: Addresses) : AccountsNamesDTO {
        val localVarResponse = getAccountsNamesWithHttpInfo(addresses = addresses)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountsNamesDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get readable names for a set of accountIds
     * Returns friendly names for accounts.
     * @param addresses 
     * @return ApiResponse<AccountsNamesDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountsNamesWithHttpInfo(addresses: Addresses) : ApiResponse<AccountsNamesDTO?> {
        val localVariableConfig = getAccountsNamesRequestConfig(addresses = addresses)

        return request<Addresses, AccountsNamesDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountsNames
     *
     * @param addresses 
     * @return RequestConfig
     */
    fun getAccountsNamesRequestConfig(addresses: Addresses) : RequestConfig<Addresses> {
        val localVariableBody = addresses
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/namespaces/account/names",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get readable names for a set of mosaics
     * Returns friendly names for mosaics.
     * @param mosaicIds 
     * @return MosaicsNamesDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMosaicsNames(mosaicIds: MosaicIds) : MosaicsNamesDTO {
        val localVarResponse = getMosaicsNamesWithHttpInfo(mosaicIds = mosaicIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MosaicsNamesDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get readable names for a set of mosaics
     * Returns friendly names for mosaics.
     * @param mosaicIds 
     * @return ApiResponse<MosaicsNamesDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMosaicsNamesWithHttpInfo(mosaicIds: MosaicIds) : ApiResponse<MosaicsNamesDTO?> {
        val localVariableConfig = getMosaicsNamesRequestConfig(mosaicIds = mosaicIds)

        return request<MosaicIds, MosaicsNamesDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMosaicsNames
     *
     * @param mosaicIds 
     * @return RequestConfig
     */
    fun getMosaicsNamesRequestConfig(mosaicIds: MosaicIds) : RequestConfig<MosaicIds> {
        val localVariableBody = mosaicIds
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/namespaces/mosaic/names",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get namespace information
     * Gets the namespace for a given namespace identifier.
     * @param namespaceId Namespace identifier.
     * @return NamespaceInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNamespace(namespaceId: kotlin.String) : NamespaceInfoDTO {
        val localVarResponse = getNamespaceWithHttpInfo(namespaceId = namespaceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NamespaceInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get namespace information
     * Gets the namespace for a given namespace identifier.
     * @param namespaceId Namespace identifier.
     * @return ApiResponse<NamespaceInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNamespaceWithHttpInfo(namespaceId: kotlin.String) : ApiResponse<NamespaceInfoDTO?> {
        val localVariableConfig = getNamespaceRequestConfig(namespaceId = namespaceId)

        return request<Unit, NamespaceInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNamespace
     *
     * @param namespaceId Namespace identifier.
     * @return RequestConfig
     */
    fun getNamespaceRequestConfig(namespaceId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/namespaces/{namespaceId}".replace("{"+"namespaceId"+"}", encodeURIComponent(namespaceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get namespace merkle information
     * Gets the namespace merkle for a given namespace identifier.
     * @param namespaceId Namespace identifier.
     * @return MerkleStateInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNamespaceMerkle(namespaceId: kotlin.String) : MerkleStateInfoDTO {
        val localVarResponse = getNamespaceMerkleWithHttpInfo(namespaceId = namespaceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MerkleStateInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get namespace merkle information
     * Gets the namespace merkle for a given namespace identifier.
     * @param namespaceId Namespace identifier.
     * @return ApiResponse<MerkleStateInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNamespaceMerkleWithHttpInfo(namespaceId: kotlin.String) : ApiResponse<MerkleStateInfoDTO?> {
        val localVariableConfig = getNamespaceMerkleRequestConfig(namespaceId = namespaceId)

        return request<Unit, MerkleStateInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNamespaceMerkle
     *
     * @param namespaceId Namespace identifier.
     * @return RequestConfig
     */
    fun getNamespaceMerkleRequestConfig(namespaceId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/namespaces/{namespaceId}/merkle".replace("{"+"namespaceId"+"}", encodeURIComponent(namespaceId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get readable names for a set of namespaces
     * Returns friendly names for namespaces.
     * @param namespaceIds 
     * @return kotlin.collections.List<NamespaceNameDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNamespacesNames(namespaceIds: NamespaceIds) : kotlin.collections.List<NamespaceNameDTO> {
        val localVarResponse = getNamespacesNamesWithHttpInfo(namespaceIds = namespaceIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NamespaceNameDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get readable names for a set of namespaces
     * Returns friendly names for namespaces.
     * @param namespaceIds 
     * @return ApiResponse<kotlin.collections.List<NamespaceNameDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNamespacesNamesWithHttpInfo(namespaceIds: NamespaceIds) : ApiResponse<kotlin.collections.List<NamespaceNameDTO>?> {
        val localVariableConfig = getNamespacesNamesRequestConfig(namespaceIds = namespaceIds)

        return request<NamespaceIds, kotlin.collections.List<NamespaceNameDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNamespacesNames
     *
     * @param namespaceIds 
     * @return RequestConfig
     */
    fun getNamespacesNamesRequestConfig(namespaceIds: NamespaceIds) : RequestConfig<NamespaceIds> {
        val localVariableBody = namespaceIds
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/namespaces/names",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search namespaces
     * Gets an array of namespaces.
     * @param ownerAddress Filter by owner address. (optional)
     * @param registrationType Filter by registration type. (optional)
     * @param level0 Filter by root namespace. (optional)
     * @param aliasType Filter by alias type. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return NamespacePage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchNamespaces(ownerAddress: kotlin.String? = null, registrationType: NamespaceRegistrationTypeEnum? = null, level0: kotlin.String? = null, aliasType: AliasTypeEnum? = null, pageSize: kotlin.Int? = 10, pageNumber: kotlin.Int? = 1, offset: kotlin.String? = null, order: Order? = desc) : NamespacePage {
        val localVarResponse = searchNamespacesWithHttpInfo(ownerAddress = ownerAddress, registrationType = registrationType, level0 = level0, aliasType = aliasType, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NamespacePage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search namespaces
     * Gets an array of namespaces.
     * @param ownerAddress Filter by owner address. (optional)
     * @param registrationType Filter by registration type. (optional)
     * @param level0 Filter by root namespace. (optional)
     * @param aliasType Filter by alias type. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return ApiResponse<NamespacePage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchNamespacesWithHttpInfo(ownerAddress: kotlin.String?, registrationType: NamespaceRegistrationTypeEnum?, level0: kotlin.String?, aliasType: AliasTypeEnum?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : ApiResponse<NamespacePage?> {
        val localVariableConfig = searchNamespacesRequestConfig(ownerAddress = ownerAddress, registrationType = registrationType, level0 = level0, aliasType = aliasType, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return request<Unit, NamespacePage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchNamespaces
     *
     * @param ownerAddress Filter by owner address. (optional)
     * @param registrationType Filter by registration type. (optional)
     * @param level0 Filter by root namespace. (optional)
     * @param aliasType Filter by alias type. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return RequestConfig
     */
    fun searchNamespacesRequestConfig(ownerAddress: kotlin.String?, registrationType: NamespaceRegistrationTypeEnum?, level0: kotlin.String?, aliasType: AliasTypeEnum?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ownerAddress != null) {
                    put("ownerAddress", listOf(ownerAddress.toString()))
                }
                if (registrationType != null) {
                    put("registrationType", listOf(registrationType.toString()))
                }
                if (level0 != null) {
                    put("level0", listOf(level0.toString()))
                }
                if (aliasType != null) {
                    put("aliasType", listOf(aliasType.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageNumber != null) {
                    put("pageNumber", listOf(pageNumber.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/namespaces",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
