/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.AnnounceTransactionInfoDTO
import org.openapitools.client.models.Cosignature
import org.openapitools.client.models.ModelError
import org.openapitools.client.models.Order
import org.openapitools.client.models.TransactionIds
import org.openapitools.client.models.TransactionInfoDTO
import org.openapitools.client.models.TransactionPage
import org.openapitools.client.models.TransactionPayload
import org.openapitools.client.models.TransactionTypeEnum

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TransactionRoutesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3000")
        }
    }

    /**
     * Announce a cosignature transaction
     * Announces a cosignature transaction to the network.
     * @param cosignature 
     * @return AnnounceTransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun announceCosignatureTransaction(cosignature: Cosignature) : AnnounceTransactionInfoDTO {
        val localVarResponse = announceCosignatureTransactionWithHttpInfo(cosignature = cosignature)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnnounceTransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Announce a cosignature transaction
     * Announces a cosignature transaction to the network.
     * @param cosignature 
     * @return ApiResponse<AnnounceTransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun announceCosignatureTransactionWithHttpInfo(cosignature: Cosignature) : ApiResponse<AnnounceTransactionInfoDTO?> {
        val localVariableConfig = announceCosignatureTransactionRequestConfig(cosignature = cosignature)

        return request<Cosignature, AnnounceTransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation announceCosignatureTransaction
     *
     * @param cosignature 
     * @return RequestConfig
     */
    fun announceCosignatureTransactionRequestConfig(cosignature: Cosignature) : RequestConfig<Cosignature> {
        val localVariableBody = cosignature
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/transactions/cosignature",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Announce an aggregate bonded transaction
     * Announces an aggregate bonded transaction to the network.
     * @param transactionPayload 
     * @return AnnounceTransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun announcePartialTransaction(transactionPayload: TransactionPayload) : AnnounceTransactionInfoDTO {
        val localVarResponse = announcePartialTransactionWithHttpInfo(transactionPayload = transactionPayload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnnounceTransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Announce an aggregate bonded transaction
     * Announces an aggregate bonded transaction to the network.
     * @param transactionPayload 
     * @return ApiResponse<AnnounceTransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun announcePartialTransactionWithHttpInfo(transactionPayload: TransactionPayload) : ApiResponse<AnnounceTransactionInfoDTO?> {
        val localVariableConfig = announcePartialTransactionRequestConfig(transactionPayload = transactionPayload)

        return request<TransactionPayload, AnnounceTransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation announcePartialTransaction
     *
     * @param transactionPayload 
     * @return RequestConfig
     */
    fun announcePartialTransactionRequestConfig(transactionPayload: TransactionPayload) : RequestConfig<TransactionPayload> {
        val localVariableBody = transactionPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/transactions/partial",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Announce a new transaction
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It&#39;s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
     * @param transactionPayload 
     * @return AnnounceTransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun announceTransaction(transactionPayload: TransactionPayload) : AnnounceTransactionInfoDTO {
        val localVarResponse = announceTransactionWithHttpInfo(transactionPayload = transactionPayload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnnounceTransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Announce a new transaction
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It&#39;s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
     * @param transactionPayload 
     * @return ApiResponse<AnnounceTransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun announceTransactionWithHttpInfo(transactionPayload: TransactionPayload) : ApiResponse<AnnounceTransactionInfoDTO?> {
        val localVariableConfig = announceTransactionRequestConfig(transactionPayload = transactionPayload)

        return request<TransactionPayload, AnnounceTransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation announceTransaction
     *
     * @param transactionPayload 
     * @return RequestConfig
     */
    fun announceTransactionRequestConfig(transactionPayload: TransactionPayload) : RequestConfig<TransactionPayload> {
        val localVariableBody = transactionPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get confirmed transaction information
     * Returns confirmed transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return TransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfirmedTransaction(transactionId: kotlin.String) : TransactionInfoDTO {
        val localVarResponse = getConfirmedTransactionWithHttpInfo(transactionId = transactionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get confirmed transaction information
     * Returns confirmed transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return ApiResponse<TransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfirmedTransactionWithHttpInfo(transactionId: kotlin.String) : ApiResponse<TransactionInfoDTO?> {
        val localVariableConfig = getConfirmedTransactionRequestConfig(transactionId = transactionId)

        return request<Unit, TransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfirmedTransaction
     *
     * @param transactionId Transaction id or hash.
     * @return RequestConfig
     */
    fun getConfirmedTransactionRequestConfig(transactionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/confirmed/{transactionId}".replace("{"+"transactionId"+"}", encodeURIComponent(transactionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get confirmed trasactions information
     * Returns confirmed transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return kotlin.collections.List<TransactionInfoDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfirmedTransactions(transactionIds: TransactionIds) : kotlin.collections.List<TransactionInfoDTO> {
        val localVarResponse = getConfirmedTransactionsWithHttpInfo(transactionIds = transactionIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionInfoDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get confirmed trasactions information
     * Returns confirmed transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return ApiResponse<kotlin.collections.List<TransactionInfoDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfirmedTransactionsWithHttpInfo(transactionIds: TransactionIds) : ApiResponse<kotlin.collections.List<TransactionInfoDTO>?> {
        val localVariableConfig = getConfirmedTransactionsRequestConfig(transactionIds = transactionIds)

        return request<TransactionIds, kotlin.collections.List<TransactionInfoDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfirmedTransactions
     *
     * @param transactionIds 
     * @return RequestConfig
     */
    fun getConfirmedTransactionsRequestConfig(transactionIds: TransactionIds) : RequestConfig<TransactionIds> {
        val localVariableBody = transactionIds
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/transactions/confirmed",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get partial transaction information
     * Returns partial transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return TransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPartialTransaction(transactionId: kotlin.String) : TransactionInfoDTO {
        val localVarResponse = getPartialTransactionWithHttpInfo(transactionId = transactionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get partial transaction information
     * Returns partial transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return ApiResponse<TransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPartialTransactionWithHttpInfo(transactionId: kotlin.String) : ApiResponse<TransactionInfoDTO?> {
        val localVariableConfig = getPartialTransactionRequestConfig(transactionId = transactionId)

        return request<Unit, TransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPartialTransaction
     *
     * @param transactionId Transaction id or hash.
     * @return RequestConfig
     */
    fun getPartialTransactionRequestConfig(transactionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/partial/{transactionId}".replace("{"+"transactionId"+"}", encodeURIComponent(transactionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get partial trasactions information
     * Returns partial transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return kotlin.collections.List<TransactionInfoDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPartialTransactions(transactionIds: TransactionIds) : kotlin.collections.List<TransactionInfoDTO> {
        val localVarResponse = getPartialTransactionsWithHttpInfo(transactionIds = transactionIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionInfoDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get partial trasactions information
     * Returns partial transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return ApiResponse<kotlin.collections.List<TransactionInfoDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPartialTransactionsWithHttpInfo(transactionIds: TransactionIds) : ApiResponse<kotlin.collections.List<TransactionInfoDTO>?> {
        val localVariableConfig = getPartialTransactionsRequestConfig(transactionIds = transactionIds)

        return request<TransactionIds, kotlin.collections.List<TransactionInfoDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPartialTransactions
     *
     * @param transactionIds 
     * @return RequestConfig
     */
    fun getPartialTransactionsRequestConfig(transactionIds: TransactionIds) : RequestConfig<TransactionIds> {
        val localVariableBody = transactionIds
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/transactions/partial",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get unconfirmed transaction information
     * Returns unconfirmed transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return TransactionInfoDTO
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUnconfirmedTransaction(transactionId: kotlin.String) : TransactionInfoDTO {
        val localVarResponse = getUnconfirmedTransactionWithHttpInfo(transactionId = transactionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionInfoDTO
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get unconfirmed transaction information
     * Returns unconfirmed transaction information given a transactionId or hash.
     * @param transactionId Transaction id or hash.
     * @return ApiResponse<TransactionInfoDTO?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUnconfirmedTransactionWithHttpInfo(transactionId: kotlin.String) : ApiResponse<TransactionInfoDTO?> {
        val localVariableConfig = getUnconfirmedTransactionRequestConfig(transactionId = transactionId)

        return request<Unit, TransactionInfoDTO>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUnconfirmedTransaction
     *
     * @param transactionId Transaction id or hash.
     * @return RequestConfig
     */
    fun getUnconfirmedTransactionRequestConfig(transactionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/unconfirmed/{transactionId}".replace("{"+"transactionId"+"}", encodeURIComponent(transactionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get unconfirmed trasactions information
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return kotlin.collections.List<TransactionInfoDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUnconfirmedTransactions(transactionIds: TransactionIds) : kotlin.collections.List<TransactionInfoDTO> {
        val localVarResponse = getUnconfirmedTransactionsWithHttpInfo(transactionIds = transactionIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TransactionInfoDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get unconfirmed trasactions information
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * @param transactionIds 
     * @return ApiResponse<kotlin.collections.List<TransactionInfoDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUnconfirmedTransactionsWithHttpInfo(transactionIds: TransactionIds) : ApiResponse<kotlin.collections.List<TransactionInfoDTO>?> {
        val localVariableConfig = getUnconfirmedTransactionsRequestConfig(transactionIds = transactionIds)

        return request<TransactionIds, kotlin.collections.List<TransactionInfoDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUnconfirmedTransactions
     *
     * @param transactionIds 
     * @return RequestConfig
     */
    fun getUnconfirmedTransactionsRequestConfig(transactionIds: TransactionIds) : RequestConfig<TransactionIds> {
        val localVariableBody = transactionIds
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/transactions/unconfirmed",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search confirmed transactions
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return TransactionPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchConfirmedTransactions(address: kotlin.String? = null, recipientAddress: kotlin.String? = null, signerPublicKey: kotlin.String? = null, height: kotlin.String? = null, fromHeight: kotlin.String? = null, toHeight: kotlin.String? = null, fromTransferAmount: kotlin.String? = null, toTransferAmount: kotlin.String? = null, type: kotlin.collections.List<TransactionTypeEnum>? = null, embedded: kotlin.Boolean? = false, transferMosaicId: kotlin.String? = null, pageSize: kotlin.Int? = 10, pageNumber: kotlin.Int? = 1, offset: kotlin.String? = null, order: Order? = desc) : TransactionPage {
        val localVarResponse = searchConfirmedTransactionsWithHttpInfo(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search confirmed transactions
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return ApiResponse<TransactionPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchConfirmedTransactionsWithHttpInfo(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : ApiResponse<TransactionPage?> {
        val localVariableConfig = searchConfirmedTransactionsRequestConfig(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return request<Unit, TransactionPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchConfirmedTransactions
     *
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return RequestConfig
     */
    fun searchConfirmedTransactionsRequestConfig(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (recipientAddress != null) {
                    put("recipientAddress", listOf(recipientAddress.toString()))
                }
                if (signerPublicKey != null) {
                    put("signerPublicKey", listOf(signerPublicKey.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (fromHeight != null) {
                    put("fromHeight", listOf(fromHeight.toString()))
                }
                if (toHeight != null) {
                    put("toHeight", listOf(toHeight.toString()))
                }
                if (fromTransferAmount != null) {
                    put("fromTransferAmount", listOf(fromTransferAmount.toString()))
                }
                if (toTransferAmount != null) {
                    put("toTransferAmount", listOf(toTransferAmount.toString()))
                }
                if (type != null) {
                    put("type", toMultiValue(type.toList(), "multi"))
                }
                if (embedded != null) {
                    put("embedded", listOf(embedded.toString()))
                }
                if (transferMosaicId != null) {
                    put("transferMosaicId", listOf(transferMosaicId.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageNumber != null) {
                    put("pageNumber", listOf(pageNumber.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/confirmed",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search partial transactions
     * Returns an array of partial transactions.
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return TransactionPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchPartialTransactions(address: kotlin.String? = null, recipientAddress: kotlin.String? = null, signerPublicKey: kotlin.String? = null, height: kotlin.String? = null, fromHeight: kotlin.String? = null, toHeight: kotlin.String? = null, fromTransferAmount: kotlin.String? = null, toTransferAmount: kotlin.String? = null, type: kotlin.collections.List<TransactionTypeEnum>? = null, embedded: kotlin.Boolean? = false, transferMosaicId: kotlin.String? = null, pageSize: kotlin.Int? = 10, pageNumber: kotlin.Int? = 1, offset: kotlin.String? = null, order: Order? = desc) : TransactionPage {
        val localVarResponse = searchPartialTransactionsWithHttpInfo(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search partial transactions
     * Returns an array of partial transactions.
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return ApiResponse<TransactionPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchPartialTransactionsWithHttpInfo(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : ApiResponse<TransactionPage?> {
        val localVariableConfig = searchPartialTransactionsRequestConfig(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return request<Unit, TransactionPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchPartialTransactions
     *
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return RequestConfig
     */
    fun searchPartialTransactionsRequestConfig(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (recipientAddress != null) {
                    put("recipientAddress", listOf(recipientAddress.toString()))
                }
                if (signerPublicKey != null) {
                    put("signerPublicKey", listOf(signerPublicKey.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (fromHeight != null) {
                    put("fromHeight", listOf(fromHeight.toString()))
                }
                if (toHeight != null) {
                    put("toHeight", listOf(toHeight.toString()))
                }
                if (fromTransferAmount != null) {
                    put("fromTransferAmount", listOf(fromTransferAmount.toString()))
                }
                if (toTransferAmount != null) {
                    put("toTransferAmount", listOf(toTransferAmount.toString()))
                }
                if (type != null) {
                    put("type", toMultiValue(type.toList(), "multi"))
                }
                if (embedded != null) {
                    put("embedded", listOf(embedded.toString()))
                }
                if (transferMosaicId != null) {
                    put("transferMosaicId", listOf(transferMosaicId.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageNumber != null) {
                    put("pageNumber", listOf(pageNumber.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/partial",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Search unconfirmed transactions
     * Returns an array of unconfirmed transactions.
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return TransactionPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchUnconfirmedTransactions(address: kotlin.String? = null, recipientAddress: kotlin.String? = null, signerPublicKey: kotlin.String? = null, height: kotlin.String? = null, fromHeight: kotlin.String? = null, toHeight: kotlin.String? = null, fromTransferAmount: kotlin.String? = null, toTransferAmount: kotlin.String? = null, type: kotlin.collections.List<TransactionTypeEnum>? = null, embedded: kotlin.Boolean? = false, transferMosaicId: kotlin.String? = null, pageSize: kotlin.Int? = 10, pageNumber: kotlin.Int? = 1, offset: kotlin.String? = null, order: Order? = desc) : TransactionPage {
        val localVarResponse = searchUnconfirmedTransactionsWithHttpInfo(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search unconfirmed transactions
     * Returns an array of unconfirmed transactions.
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return ApiResponse<TransactionPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchUnconfirmedTransactionsWithHttpInfo(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : ApiResponse<TransactionPage?> {
        val localVariableConfig = searchUnconfirmedTransactionsRequestConfig(address = address, recipientAddress = recipientAddress, signerPublicKey = signerPublicKey, height = height, fromHeight = fromHeight, toHeight = toHeight, fromTransferAmount = fromTransferAmount, toTransferAmount = toTransferAmount, type = type, embedded = embedded, transferMosaicId = transferMosaicId, pageSize = pageSize, pageNumber = pageNumber, offset = offset, order = order)

        return request<Unit, TransactionPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchUnconfirmedTransactions
     *
     * @param address Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.  (optional)
     * @param recipientAddress Filter by address of the account receiving the transaction. (optional)
     * @param signerPublicKey Filter by public key of the account signing the entity. (optional)
     * @param height Filter by block height. (optional)
     * @param fromHeight Only blocks with height greater or equal than this one are returned. (optional)
     * @param toHeight Only blocks with height smaller or equal than this one are returned. (optional)
     * @param fromTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.  (optional)
     * @param toTransferAmount Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.  (optional)
     * @param type Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.  (optional)
     * @param embedded When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.  (optional, default to false)
     * @param transferMosaicId Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;. (optional)
     * @param pageSize Select the number of entries to return. (optional, default to 10)
     * @param pageNumber Filter by page number. (optional, default to 1)
     * @param offset Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)
     * @param order Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional, default to desc)
     * @return RequestConfig
     */
    fun searchUnconfirmedTransactionsRequestConfig(address: kotlin.String?, recipientAddress: kotlin.String?, signerPublicKey: kotlin.String?, height: kotlin.String?, fromHeight: kotlin.String?, toHeight: kotlin.String?, fromTransferAmount: kotlin.String?, toTransferAmount: kotlin.String?, type: kotlin.collections.List<TransactionTypeEnum>?, embedded: kotlin.Boolean?, transferMosaicId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?, offset: kotlin.String?, order: Order?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (recipientAddress != null) {
                    put("recipientAddress", listOf(recipientAddress.toString()))
                }
                if (signerPublicKey != null) {
                    put("signerPublicKey", listOf(signerPublicKey.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (fromHeight != null) {
                    put("fromHeight", listOf(fromHeight.toString()))
                }
                if (toHeight != null) {
                    put("toHeight", listOf(toHeight.toString()))
                }
                if (fromTransferAmount != null) {
                    put("fromTransferAmount", listOf(fromTransferAmount.toString()))
                }
                if (toTransferAmount != null) {
                    put("toTransferAmount", listOf(toTransferAmount.toString()))
                }
                if (type != null) {
                    put("type", toMultiValue(type.toList(), "multi"))
                }
                if (embedded != null) {
                    put("embedded", listOf(embedded.toString()))
                }
                if (transferMosaicId != null) {
                    put("transferMosaicId", listOf(transferMosaicId.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageNumber != null) {
                    put("pageNumber", listOf(pageNumber.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions/unconfirmed",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
