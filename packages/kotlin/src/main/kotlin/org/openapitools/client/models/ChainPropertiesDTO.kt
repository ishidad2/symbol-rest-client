/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models


import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * Chain related configuration properties.
 *
 * @param enableVerifiableState Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.
 * @param enableVerifiableReceipts Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.
 * @param currencyMosaicId Mosaic id used as primary chain currency.
 * @param harvestingMosaicId Mosaic id used to provide harvesting ability.
 * @param blockGenerationTargetTime Targeted time between blocks.
 * @param blockTimeSmoothingFactor A higher value makes the network more biased.
 * @param blockFinalizationInterval Number of blocks between successive finalization attempts.
 * @param importanceGrouping Number of blocks that should be treated as a group for importance purposes.
 * @param importanceActivityPercentage Percentage of importance resulting from fee generation and beneficiary usage.
 * @param maxRollbackBlocks Maximum number of blocks that can be rolled back.
 * @param maxDifficultyBlocks Maximum number of blocks to use in a difficulty calculation.
 * @param defaultDynamicFeeMultiplier Default multiplier to use for dynamic fees.
 * @param maxTransactionLifetime Maximum lifetime a transaction can have before it expires.
 * @param maxBlockFutureTime Maximum future time of a block that can be accepted.
 * @param initialCurrencyAtomicUnits Initial currency atomic units available in the network.
 * @param maxMosaicAtomicUnits Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.
 * @param totalChainImportance Total whole importance units available in the network.
 * @param minHarvesterBalance Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
 * @param maxHarvesterBalance Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
 * @param minVoterBalance Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.
 * @param maxVotingKeysPerAccount Maximum number of voting keys that can be registered at once per account.
 * @param minVotingKeyLifetime Minimum number of finalization rounds for which voting key can be registered.
 * @param maxVotingKeyLifetime Maximum number of finalization rounds for which voting key can be registered.
 * @param harvestBeneficiaryPercentage Percentage of the harvested fee that is collected by the beneficiary account.
 * @param harvestNetworkPercentage Percentage of the harvested fee that is collected by the network.
 * @param harvestNetworkFeeSinkAddress Address encoded using a 32-character set.
 * @param blockPruneInterval Number of blocks between cache pruning.
 * @param maxTransactionsPerBlock Maximum number of transactions per block.
 */


data class ChainPropertiesDTO (

    /* Set to true if block chain should calculate state hashes so that state is fully verifiable at each block. */
    @Json(name = "enableVerifiableState")
    val enableVerifiableState: kotlin.Boolean? = null,

    /* Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block. */
    @Json(name = "enableVerifiableReceipts")
    val enableVerifiableReceipts: kotlin.Boolean? = null,

    /* Mosaic id used as primary chain currency. */
    @Json(name = "currencyMosaicId")
    val currencyMosaicId: kotlin.String? = null,

    /* Mosaic id used to provide harvesting ability. */
    @Json(name = "harvestingMosaicId")
    val harvestingMosaicId: kotlin.String? = null,

    /* Targeted time between blocks. */
    @Json(name = "blockGenerationTargetTime")
    val blockGenerationTargetTime: kotlin.String? = null,

    /* A higher value makes the network more biased. */
    @Json(name = "blockTimeSmoothingFactor")
    val blockTimeSmoothingFactor: kotlin.String? = null,

    /* Number of blocks between successive finalization attempts. */
    @Json(name = "blockFinalizationInterval")
    val blockFinalizationInterval: kotlin.String? = null,

    /* Number of blocks that should be treated as a group for importance purposes. */
    @Json(name = "importanceGrouping")
    val importanceGrouping: kotlin.String? = null,

    /* Percentage of importance resulting from fee generation and beneficiary usage. */
    @Json(name = "importanceActivityPercentage")
    val importanceActivityPercentage: kotlin.String? = null,

    /* Maximum number of blocks that can be rolled back. */
    @Json(name = "maxRollbackBlocks")
    val maxRollbackBlocks: kotlin.String? = null,

    /* Maximum number of blocks to use in a difficulty calculation. */
    @Json(name = "maxDifficultyBlocks")
    val maxDifficultyBlocks: kotlin.String? = null,

    /* Default multiplier to use for dynamic fees. */
    @Json(name = "defaultDynamicFeeMultiplier")
    val defaultDynamicFeeMultiplier: kotlin.String? = null,

    /* Maximum lifetime a transaction can have before it expires. */
    @Json(name = "maxTransactionLifetime")
    val maxTransactionLifetime: kotlin.String? = null,

    /* Maximum future time of a block that can be accepted. */
    @Json(name = "maxBlockFutureTime")
    val maxBlockFutureTime: kotlin.String? = null,

    /* Initial currency atomic units available in the network. */
    @Json(name = "initialCurrencyAtomicUnits")
    val initialCurrencyAtomicUnits: kotlin.String? = null,

    /* Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network. */
    @Json(name = "maxMosaicAtomicUnits")
    val maxMosaicAtomicUnits: kotlin.String? = null,

    /* Total whole importance units available in the network. */
    @Json(name = "totalChainImportance")
    val totalChainImportance: kotlin.String? = null,

    /* Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting. */
    @Json(name = "minHarvesterBalance")
    val minHarvesterBalance: kotlin.String? = null,

    /* Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting. */
    @Json(name = "maxHarvesterBalance")
    val maxHarvesterBalance: kotlin.String? = null,

    /* Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting. */
    @Json(name = "minVoterBalance")
    val minVoterBalance: kotlin.String? = null,

    /* Maximum number of voting keys that can be registered at once per account. */
    @Json(name = "maxVotingKeysPerAccount")
    val maxVotingKeysPerAccount: kotlin.String? = null,

    /* Minimum number of finalization rounds for which voting key can be registered. */
    @Json(name = "minVotingKeyLifetime")
    val minVotingKeyLifetime: kotlin.String? = null,

    /* Maximum number of finalization rounds for which voting key can be registered. */
    @Json(name = "maxVotingKeyLifetime")
    val maxVotingKeyLifetime: kotlin.String? = null,

    /* Percentage of the harvested fee that is collected by the beneficiary account. */
    @Json(name = "harvestBeneficiaryPercentage")
    val harvestBeneficiaryPercentage: kotlin.String? = null,

    /* Percentage of the harvested fee that is collected by the network. */
    @Json(name = "harvestNetworkPercentage")
    val harvestNetworkPercentage: kotlin.String? = null,

    /* Address encoded using a 32-character set. */
    @Json(name = "harvestNetworkFeeSinkAddress")
    val harvestNetworkFeeSinkAddress: kotlin.String? = null,

    /* Number of blocks between cache pruning. */
    @Json(name = "blockPruneInterval")
    val blockPruneInterval: kotlin.String? = null,

    /* Maximum number of transactions per block. */
    @Json(name = "maxTransactionsPerBlock")
    val maxTransactionsPerBlock: kotlin.String? = null

)

