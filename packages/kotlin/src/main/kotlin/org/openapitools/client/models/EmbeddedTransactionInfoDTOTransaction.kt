/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models

import org.openapitools.client.models.AccountRestrictionFlagsEnum
import org.openapitools.client.models.AliasActionEnum
import org.openapitools.client.models.EmbeddedAccountAddressRestrictionTransactionDTO
import org.openapitools.client.models.EmbeddedAccountKeyLinkTransactionDTO
import org.openapitools.client.models.EmbeddedAccountMetadataTransactionDTO
import org.openapitools.client.models.EmbeddedAccountMosaicRestrictionTransactionDTO
import org.openapitools.client.models.EmbeddedAccountOperationRestrictionTransactionDTO
import org.openapitools.client.models.EmbeddedAddressAliasTransactionDTO
import org.openapitools.client.models.EmbeddedHashLockTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicAddressRestrictionTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicAliasTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicDefinitionTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicGlobalRestrictionTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicMetadataTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicSupplyChangeTransactionDTO
import org.openapitools.client.models.EmbeddedMosaicSupplyRevocationTransactionDTO
import org.openapitools.client.models.EmbeddedMultisigAccountModificationTransactionDTO
import org.openapitools.client.models.EmbeddedNamespaceMetadataTransactionDTO
import org.openapitools.client.models.EmbeddedNamespaceRegistrationTransactionDTO
import org.openapitools.client.models.EmbeddedNodeKeyLinkTransactionDTO
import org.openapitools.client.models.EmbeddedSecretLockTransactionDTO
import org.openapitools.client.models.EmbeddedSecretProofTransactionDTO
import org.openapitools.client.models.EmbeddedTransferTransactionDTO
import org.openapitools.client.models.EmbeddedVotingKeyLinkTransactionDTO
import org.openapitools.client.models.EmbeddedVrfKeyLinkTransactionDTO
import org.openapitools.client.models.LinkActionEnum
import org.openapitools.client.models.LockHashAlgorithmEnum
import org.openapitools.client.models.MosaicRestrictionTypeEnum
import org.openapitools.client.models.MosaicSupplyChangeActionEnum
import org.openapitools.client.models.NamespaceRegistrationTypeEnum
import org.openapitools.client.models.NetworkTypeEnum
import org.openapitools.client.models.TransactionTypeEnum
import org.openapitools.client.models.UnresolvedMosaic

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

/**
 * 
 *
 * @param signerPublicKey Public key.
 * @param version Entity version.
 * @param network 
 * @param type 
 * @param linkedPublicKey 32 bytes voting public key.
 * @param linkAction 
 * @param startEpoch Finalization Epoch
 * @param endEpoch Finalization Epoch
 * @param mosaicId Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
 * @param amount Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
 * @param duration Duration expressed in number of blocks.
 * @param hash 
 * @param recipientAddress Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
 * @param secret 
 * @param hashAlgorithm 
 * @param proof Original random set of bytes.
 * @param targetAddress Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
 * @param scopedMetadataKey Metadata key scoped to source, target and type expressed.
 * @param valueSizeDelta Change in value size in bytes.
 * @param valueSize A number that allows uint 32 values.
 * @param `value` Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
 * @param targetMosaicId Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
 * @param id Namespace identifier.
 * @param nonce A number that allows uint 32 values.
 * @param flags - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
 * @param divisibility Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
 * @param delta Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
 * @param action 
 * @param sourceAddress Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
 * @param registrationType 
 * @param name Namespace name.
 * @param namespaceId Namespace identifier.
 * @param address Address encoded using a 32-character set.
 * @param aliasAction 
 * @param minRemovalDelta Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
 * @param minApprovalDelta Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
 * @param addressAdditions Array of cosignatory accounts to add.
 * @param addressDeletions Array of cosignatory accounts to delete.
 * @param restrictionFlags 
 * @param restrictionAdditions Account restriction additions.
 * @param restrictionDeletions Account restriction deletions.
 * @param referenceMosaicId Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
 * @param restrictionKey Restriction key.
 * @param previousRestrictionValue Restriction value.
 * @param newRestrictionValue Restriction value.
 * @param previousRestrictionType 
 * @param newRestrictionType 
 * @param mosaics Array of mosaics sent to the recipient. 
 * @param targetNamespaceId Namespace identifier.
 * @param parentId Namespace identifier.
 * @param message Transfer transaction message
 */


data class EmbeddedTransactionInfoDTOTransaction (

    /* Public key. */
    @Json(name = "signerPublicKey")
    val signerPublicKey: kotlin.String,

    /* Entity version. */
    @Json(name = "version")
    val version: kotlin.Int,

    @Json(name = "network")
    val network: NetworkTypeEnum,

    @Json(name = "type")
    val type: kotlin.Int,

    /* 32 bytes voting public key. */
    @Json(name = "linkedPublicKey")
    val linkedPublicKey: kotlin.String,

    @Json(name = "linkAction")
    val linkAction: LinkActionEnum,

    /* Finalization Epoch */
    @Json(name = "startEpoch")
    val startEpoch: kotlin.Long,

    /* Finalization Epoch */
    @Json(name = "endEpoch")
    val endEpoch: kotlin.Long,

    /* Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  */
    @Json(name = "mosaicId")
    val mosaicId: kotlin.String,

    /* Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative). */
    @Json(name = "amount")
    val amount: kotlin.String,

    /* Duration expressed in number of blocks. */
    @Json(name = "duration")
    val duration: kotlin.String,

    @Json(name = "hash")
    val hash: kotlin.String,

    /* Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  */
    @Json(name = "recipientAddress")
    val recipientAddress: kotlin.String,

    @Json(name = "secret")
    val secret: kotlin.String,

    @Json(name = "hashAlgorithm")
    val hashAlgorithm: LockHashAlgorithmEnum,

    /* Original random set of bytes. */
    @Json(name = "proof")
    val proof: kotlin.String,

    /* Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  */
    @Json(name = "targetAddress")
    val targetAddress: kotlin.String,

    /* Metadata key scoped to source, target and type expressed. */
    @Json(name = "scopedMetadataKey")
    val scopedMetadataKey: kotlin.String,

    /* Change in value size in bytes. */
    @Json(name = "valueSizeDelta")
    val valueSizeDelta: kotlin.Int,

    /* A number that allows uint 32 values. */
    @Json(name = "valueSize")
    val valueSize: kotlin.Long,

    /* Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value). */
    @Json(name = "value")
    val `value`: kotlin.String,

    /* Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  */
    @Json(name = "targetMosaicId")
    val targetMosaicId: kotlin.String,

    /* Namespace identifier. */
    @Json(name = "id")
    val id: kotlin.String,

    /* A number that allows uint 32 values. */
    @Json(name = "nonce")
    val nonce: kotlin.Long,

    /* - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user.  */
    @Json(name = "flags")
    val flags: kotlin.Int,

    /* Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6.  */
    @Json(name = "divisibility")
    val divisibility: kotlin.Int,

    /* Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative). */
    @Json(name = "delta")
    val delta: kotlin.String,

    @Json(name = "action")
    val action: MosaicSupplyChangeActionEnum,

    /* Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA  */
    @Json(name = "sourceAddress")
    val sourceAddress: kotlin.String,

    @Json(name = "registrationType")
    val registrationType: NamespaceRegistrationTypeEnum,

    /* Namespace name. */
    @Json(name = "name")
    val name: kotlin.String,

    /* Namespace identifier. */
    @Json(name = "namespaceId")
    val namespaceId: kotlin.String,

    /* Address encoded using a 32-character set. */
    @Json(name = "address")
    val address: kotlin.String,

    @Json(name = "aliasAction")
    val aliasAction: AliasActionEnum,

    /* Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.  */
    @Json(name = "minRemovalDelta")
    val minRemovalDelta: kotlin.Int,

    /* Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.  */
    @Json(name = "minApprovalDelta")
    val minApprovalDelta: kotlin.Int,

    /* Array of cosignatory accounts to add. */
    @Json(name = "addressAdditions")
    val addressAdditions: kotlin.collections.List<kotlin.String>,

    /* Array of cosignatory accounts to delete. */
    @Json(name = "addressDeletions")
    val addressDeletions: kotlin.collections.List<kotlin.String>,

    @Json(name = "restrictionFlags")
    val restrictionFlags: AccountRestrictionFlagsEnum,

    /* Account restriction additions. */
    @Json(name = "restrictionAdditions")
    val restrictionAdditions: kotlin.collections.List<TransactionTypeEnum>,

    /* Account restriction deletions. */
    @Json(name = "restrictionDeletions")
    val restrictionDeletions: kotlin.collections.List<TransactionTypeEnum>,

    /* Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier.  */
    @Json(name = "referenceMosaicId")
    val referenceMosaicId: kotlin.String,

    /* Restriction key. */
    @Json(name = "restrictionKey")
    val restrictionKey: kotlin.String,

    /* Restriction value. */
    @Json(name = "previousRestrictionValue")
    val previousRestrictionValue: kotlin.String,

    /* Restriction value. */
    @Json(name = "newRestrictionValue")
    val newRestrictionValue: kotlin.String,

    @Json(name = "previousRestrictionType")
    val previousRestrictionType: MosaicRestrictionTypeEnum,

    @Json(name = "newRestrictionType")
    val newRestrictionType: MosaicRestrictionTypeEnum,

    /* Array of mosaics sent to the recipient.  */
    @Json(name = "mosaics")
    val mosaics: kotlin.collections.List<UnresolvedMosaic>,

    /* Namespace identifier. */
    @Json(name = "targetNamespaceId")
    val targetNamespaceId: kotlin.String? = null,

    /* Namespace identifier. */
    @Json(name = "parentId")
    val parentId: kotlin.String? = null,

    /* Transfer transaction message */
    @Json(name = "message")
    val message: kotlin.String? = null

)

