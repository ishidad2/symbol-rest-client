/*
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountRestrictionFlagsEnum;
import org.openapitools.client.model.AliasActionEnum;
import org.openapitools.client.model.EmbeddedAccountAddressRestrictionTransactionDTO;
import org.openapitools.client.model.EmbeddedAccountKeyLinkTransactionDTO;
import org.openapitools.client.model.EmbeddedAccountMetadataTransactionDTO;
import org.openapitools.client.model.EmbeddedAccountMosaicRestrictionTransactionDTO;
import org.openapitools.client.model.EmbeddedAccountOperationRestrictionTransactionDTO;
import org.openapitools.client.model.EmbeddedAddressAliasTransactionDTO;
import org.openapitools.client.model.EmbeddedHashLockTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicAddressRestrictionTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicAliasTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicDefinitionTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicGlobalRestrictionTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicMetadataTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicSupplyChangeTransactionDTO;
import org.openapitools.client.model.EmbeddedMosaicSupplyRevocationTransactionDTO;
import org.openapitools.client.model.EmbeddedMultisigAccountModificationTransactionDTO;
import org.openapitools.client.model.EmbeddedNamespaceMetadataTransactionDTO;
import org.openapitools.client.model.EmbeddedNamespaceRegistrationTransactionDTO;
import org.openapitools.client.model.EmbeddedNodeKeyLinkTransactionDTO;
import org.openapitools.client.model.EmbeddedSecretLockTransactionDTO;
import org.openapitools.client.model.EmbeddedSecretProofTransactionDTO;
import org.openapitools.client.model.EmbeddedTransferTransactionDTO;
import org.openapitools.client.model.EmbeddedVotingKeyLinkTransactionDTO;
import org.openapitools.client.model.EmbeddedVrfKeyLinkTransactionDTO;
import org.openapitools.client.model.LinkActionEnum;
import org.openapitools.client.model.LockHashAlgorithmEnum;
import org.openapitools.client.model.MosaicRestrictionTypeEnum;
import org.openapitools.client.model.MosaicSupplyChangeActionEnum;
import org.openapitools.client.model.NamespaceRegistrationTypeEnum;
import org.openapitools.client.model.NetworkTypeEnum;
import org.openapitools.client.model.TransactionTypeEnum;
import org.openapitools.client.model.UnresolvedMosaic;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-02T22:49:20.273938+09:00[Asia/Tokyo]")
public class EmbeddedTransactionInfoDTOTransaction extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(EmbeddedTransactionInfoDTOTransaction.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!EmbeddedTransactionInfoDTOTransaction.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'EmbeddedTransactionInfoDTOTransaction' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<EmbeddedAccountKeyLinkTransactionDTO> adapterEmbeddedAccountKeyLinkTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAccountKeyLinkTransactionDTO.class));
            final TypeAdapter<EmbeddedNodeKeyLinkTransactionDTO> adapterEmbeddedNodeKeyLinkTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedNodeKeyLinkTransactionDTO.class));
            final TypeAdapter<EmbeddedVrfKeyLinkTransactionDTO> adapterEmbeddedVrfKeyLinkTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedVrfKeyLinkTransactionDTO.class));
            final TypeAdapter<EmbeddedVotingKeyLinkTransactionDTO> adapterEmbeddedVotingKeyLinkTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedVotingKeyLinkTransactionDTO.class));
            final TypeAdapter<EmbeddedHashLockTransactionDTO> adapterEmbeddedHashLockTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedHashLockTransactionDTO.class));
            final TypeAdapter<EmbeddedSecretLockTransactionDTO> adapterEmbeddedSecretLockTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedSecretLockTransactionDTO.class));
            final TypeAdapter<EmbeddedSecretProofTransactionDTO> adapterEmbeddedSecretProofTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedSecretProofTransactionDTO.class));
            final TypeAdapter<EmbeddedAccountMetadataTransactionDTO> adapterEmbeddedAccountMetadataTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAccountMetadataTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicMetadataTransactionDTO> adapterEmbeddedMosaicMetadataTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicMetadataTransactionDTO.class));
            final TypeAdapter<EmbeddedNamespaceMetadataTransactionDTO> adapterEmbeddedNamespaceMetadataTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedNamespaceMetadataTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicDefinitionTransactionDTO> adapterEmbeddedMosaicDefinitionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicDefinitionTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicSupplyChangeTransactionDTO> adapterEmbeddedMosaicSupplyChangeTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicSupplyChangeTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicSupplyRevocationTransactionDTO> adapterEmbeddedMosaicSupplyRevocationTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicSupplyRevocationTransactionDTO.class));
            final TypeAdapter<EmbeddedNamespaceRegistrationTransactionDTO> adapterEmbeddedNamespaceRegistrationTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedNamespaceRegistrationTransactionDTO.class));
            final TypeAdapter<EmbeddedAddressAliasTransactionDTO> adapterEmbeddedAddressAliasTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAddressAliasTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicAliasTransactionDTO> adapterEmbeddedMosaicAliasTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicAliasTransactionDTO.class));
            final TypeAdapter<EmbeddedMultisigAccountModificationTransactionDTO> adapterEmbeddedMultisigAccountModificationTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMultisigAccountModificationTransactionDTO.class));
            final TypeAdapter<EmbeddedAccountAddressRestrictionTransactionDTO> adapterEmbeddedAccountAddressRestrictionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAccountAddressRestrictionTransactionDTO.class));
            final TypeAdapter<EmbeddedAccountMosaicRestrictionTransactionDTO> adapterEmbeddedAccountMosaicRestrictionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAccountMosaicRestrictionTransactionDTO.class));
            final TypeAdapter<EmbeddedAccountOperationRestrictionTransactionDTO> adapterEmbeddedAccountOperationRestrictionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedAccountOperationRestrictionTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicGlobalRestrictionTransactionDTO> adapterEmbeddedMosaicGlobalRestrictionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicGlobalRestrictionTransactionDTO.class));
            final TypeAdapter<EmbeddedMosaicAddressRestrictionTransactionDTO> adapterEmbeddedMosaicAddressRestrictionTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedMosaicAddressRestrictionTransactionDTO.class));
            final TypeAdapter<EmbeddedTransferTransactionDTO> adapterEmbeddedTransferTransactionDTO = gson.getDelegateAdapter(this, TypeToken.get(EmbeddedTransferTransactionDTO.class));

            return (TypeAdapter<T>) new TypeAdapter<EmbeddedTransactionInfoDTOTransaction>() {
                @Override
                public void write(JsonWriter out, EmbeddedTransactionInfoDTOTransaction value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `EmbeddedAccountKeyLinkTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAccountKeyLinkTransactionDTO) {
                      JsonElement element = adapterEmbeddedAccountKeyLinkTransactionDTO.toJsonTree((EmbeddedAccountKeyLinkTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedNodeKeyLinkTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedNodeKeyLinkTransactionDTO) {
                      JsonElement element = adapterEmbeddedNodeKeyLinkTransactionDTO.toJsonTree((EmbeddedNodeKeyLinkTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedVrfKeyLinkTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedVrfKeyLinkTransactionDTO) {
                      JsonElement element = adapterEmbeddedVrfKeyLinkTransactionDTO.toJsonTree((EmbeddedVrfKeyLinkTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedVotingKeyLinkTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedVotingKeyLinkTransactionDTO) {
                      JsonElement element = adapterEmbeddedVotingKeyLinkTransactionDTO.toJsonTree((EmbeddedVotingKeyLinkTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedHashLockTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedHashLockTransactionDTO) {
                      JsonElement element = adapterEmbeddedHashLockTransactionDTO.toJsonTree((EmbeddedHashLockTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedSecretLockTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedSecretLockTransactionDTO) {
                      JsonElement element = adapterEmbeddedSecretLockTransactionDTO.toJsonTree((EmbeddedSecretLockTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedSecretProofTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedSecretProofTransactionDTO) {
                      JsonElement element = adapterEmbeddedSecretProofTransactionDTO.toJsonTree((EmbeddedSecretProofTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedAccountMetadataTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAccountMetadataTransactionDTO) {
                      JsonElement element = adapterEmbeddedAccountMetadataTransactionDTO.toJsonTree((EmbeddedAccountMetadataTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicMetadataTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicMetadataTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicMetadataTransactionDTO.toJsonTree((EmbeddedMosaicMetadataTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedNamespaceMetadataTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedNamespaceMetadataTransactionDTO) {
                      JsonElement element = adapterEmbeddedNamespaceMetadataTransactionDTO.toJsonTree((EmbeddedNamespaceMetadataTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicDefinitionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicDefinitionTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicDefinitionTransactionDTO.toJsonTree((EmbeddedMosaicDefinitionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicSupplyChangeTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicSupplyChangeTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicSupplyChangeTransactionDTO.toJsonTree((EmbeddedMosaicSupplyChangeTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicSupplyRevocationTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicSupplyRevocationTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicSupplyRevocationTransactionDTO.toJsonTree((EmbeddedMosaicSupplyRevocationTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedNamespaceRegistrationTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedNamespaceRegistrationTransactionDTO) {
                      JsonElement element = adapterEmbeddedNamespaceRegistrationTransactionDTO.toJsonTree((EmbeddedNamespaceRegistrationTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedAddressAliasTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAddressAliasTransactionDTO) {
                      JsonElement element = adapterEmbeddedAddressAliasTransactionDTO.toJsonTree((EmbeddedAddressAliasTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicAliasTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicAliasTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicAliasTransactionDTO.toJsonTree((EmbeddedMosaicAliasTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMultisigAccountModificationTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMultisigAccountModificationTransactionDTO) {
                      JsonElement element = adapterEmbeddedMultisigAccountModificationTransactionDTO.toJsonTree((EmbeddedMultisigAccountModificationTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedAccountAddressRestrictionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAccountAddressRestrictionTransactionDTO) {
                      JsonElement element = adapterEmbeddedAccountAddressRestrictionTransactionDTO.toJsonTree((EmbeddedAccountAddressRestrictionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedAccountMosaicRestrictionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAccountMosaicRestrictionTransactionDTO) {
                      JsonElement element = adapterEmbeddedAccountMosaicRestrictionTransactionDTO.toJsonTree((EmbeddedAccountMosaicRestrictionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedAccountOperationRestrictionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedAccountOperationRestrictionTransactionDTO) {
                      JsonElement element = adapterEmbeddedAccountOperationRestrictionTransactionDTO.toJsonTree((EmbeddedAccountOperationRestrictionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicGlobalRestrictionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicGlobalRestrictionTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicGlobalRestrictionTransactionDTO.toJsonTree((EmbeddedMosaicGlobalRestrictionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedMosaicAddressRestrictionTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedMosaicAddressRestrictionTransactionDTO) {
                      JsonElement element = adapterEmbeddedMosaicAddressRestrictionTransactionDTO.toJsonTree((EmbeddedMosaicAddressRestrictionTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    // check if the actual instance is of the type `EmbeddedTransferTransactionDTO`
                    if (value.getActualInstance() instanceof EmbeddedTransferTransactionDTO) {
                      JsonElement element = adapterEmbeddedTransferTransactionDTO.toJsonTree((EmbeddedTransferTransactionDTO)value.getActualInstance());
                      elementAdapter.write(out, element);
                      return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match anyOf schemae: EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO");
                }

                @Override
                public EmbeddedTransactionInfoDTOTransaction read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize EmbeddedAccountKeyLinkTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAccountKeyLinkTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAccountKeyLinkTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAccountKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAccountKeyLinkTransactionDTO'", e);
                    }
                    // deserialize EmbeddedNodeKeyLinkTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedNodeKeyLinkTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedNodeKeyLinkTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedNodeKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedNodeKeyLinkTransactionDTO'", e);
                    }
                    // deserialize EmbeddedVrfKeyLinkTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedVrfKeyLinkTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedVrfKeyLinkTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedVrfKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedVrfKeyLinkTransactionDTO'", e);
                    }
                    // deserialize EmbeddedVotingKeyLinkTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedVotingKeyLinkTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedVotingKeyLinkTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedVotingKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedVotingKeyLinkTransactionDTO'", e);
                    }
                    // deserialize EmbeddedHashLockTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedHashLockTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedHashLockTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedHashLockTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedHashLockTransactionDTO'", e);
                    }
                    // deserialize EmbeddedSecretLockTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedSecretLockTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedSecretLockTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedSecretLockTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedSecretLockTransactionDTO'", e);
                    }
                    // deserialize EmbeddedSecretProofTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedSecretProofTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedSecretProofTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedSecretProofTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedSecretProofTransactionDTO'", e);
                    }
                    // deserialize EmbeddedAccountMetadataTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAccountMetadataTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAccountMetadataTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAccountMetadataTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAccountMetadataTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicMetadataTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicMetadataTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicMetadataTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicMetadataTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicMetadataTransactionDTO'", e);
                    }
                    // deserialize EmbeddedNamespaceMetadataTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedNamespaceMetadataTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedNamespaceMetadataTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedNamespaceMetadataTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedNamespaceMetadataTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicDefinitionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicDefinitionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicDefinitionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicDefinitionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicDefinitionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicSupplyChangeTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicSupplyChangeTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicSupplyChangeTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicSupplyChangeTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicSupplyChangeTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicSupplyRevocationTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicSupplyRevocationTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicSupplyRevocationTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicSupplyRevocationTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicSupplyRevocationTransactionDTO'", e);
                    }
                    // deserialize EmbeddedNamespaceRegistrationTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedNamespaceRegistrationTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedNamespaceRegistrationTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedNamespaceRegistrationTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedNamespaceRegistrationTransactionDTO'", e);
                    }
                    // deserialize EmbeddedAddressAliasTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAddressAliasTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAddressAliasTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAddressAliasTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAddressAliasTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicAliasTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicAliasTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicAliasTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicAliasTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicAliasTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMultisigAccountModificationTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMultisigAccountModificationTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMultisigAccountModificationTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMultisigAccountModificationTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMultisigAccountModificationTransactionDTO'", e);
                    }
                    // deserialize EmbeddedAccountAddressRestrictionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAccountAddressRestrictionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAccountAddressRestrictionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAccountAddressRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAccountAddressRestrictionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedAccountMosaicRestrictionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAccountMosaicRestrictionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAccountMosaicRestrictionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAccountMosaicRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAccountMosaicRestrictionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedAccountOperationRestrictionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedAccountOperationRestrictionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedAccountOperationRestrictionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedAccountOperationRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedAccountOperationRestrictionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicGlobalRestrictionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicGlobalRestrictionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicGlobalRestrictionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicGlobalRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicGlobalRestrictionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedMosaicAddressRestrictionTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedMosaicAddressRestrictionTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedMosaicAddressRestrictionTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedMosaicAddressRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedMosaicAddressRestrictionTransactionDTO'", e);
                    }
                    // deserialize EmbeddedTransferTransactionDTO
                    try {
                      // validate the JSON object to see if any exception is thrown
                      EmbeddedTransferTransactionDTO.validateJsonElement(jsonElement);
                      actualAdapter = adapterEmbeddedTransferTransactionDTO;
                      EmbeddedTransactionInfoDTOTransaction ret = new EmbeddedTransactionInfoDTOTransaction();
                      ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                      return ret;
                    } catch (Exception e) {
                      // deserialization failed, continue
                      errorMessages.add(String.format("Deserialization for EmbeddedTransferTransactionDTO failed with `%s`.", e.getMessage()));
                      log.log(Level.FINER, "Input data does not match schema 'EmbeddedTransferTransactionDTO'", e);
                    }

                    throw new IOException(String.format("Failed deserialization for EmbeddedTransactionInfoDTOTransaction: no class matches result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public EmbeddedTransactionInfoDTOTransaction() {
        super("anyOf", Boolean.FALSE);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAccountAddressRestrictionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAccountKeyLinkTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAccountMetadataTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAccountMosaicRestrictionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAccountOperationRestrictionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedAddressAliasTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedHashLockTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicAddressRestrictionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicAliasTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicDefinitionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicGlobalRestrictionTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicMetadataTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicSupplyChangeTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMosaicSupplyRevocationTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedMultisigAccountModificationTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedNamespaceMetadataTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedNamespaceRegistrationTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedNodeKeyLinkTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedSecretLockTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedSecretProofTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedTransferTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedVotingKeyLinkTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EmbeddedTransactionInfoDTOTransaction(EmbeddedVrfKeyLinkTransactionDTO o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("EmbeddedAccountKeyLinkTransactionDTO", EmbeddedAccountKeyLinkTransactionDTO.class);
        schemas.put("EmbeddedNodeKeyLinkTransactionDTO", EmbeddedNodeKeyLinkTransactionDTO.class);
        schemas.put("EmbeddedVrfKeyLinkTransactionDTO", EmbeddedVrfKeyLinkTransactionDTO.class);
        schemas.put("EmbeddedVotingKeyLinkTransactionDTO", EmbeddedVotingKeyLinkTransactionDTO.class);
        schemas.put("EmbeddedHashLockTransactionDTO", EmbeddedHashLockTransactionDTO.class);
        schemas.put("EmbeddedSecretLockTransactionDTO", EmbeddedSecretLockTransactionDTO.class);
        schemas.put("EmbeddedSecretProofTransactionDTO", EmbeddedSecretProofTransactionDTO.class);
        schemas.put("EmbeddedAccountMetadataTransactionDTO", EmbeddedAccountMetadataTransactionDTO.class);
        schemas.put("EmbeddedMosaicMetadataTransactionDTO", EmbeddedMosaicMetadataTransactionDTO.class);
        schemas.put("EmbeddedNamespaceMetadataTransactionDTO", EmbeddedNamespaceMetadataTransactionDTO.class);
        schemas.put("EmbeddedMosaicDefinitionTransactionDTO", EmbeddedMosaicDefinitionTransactionDTO.class);
        schemas.put("EmbeddedMosaicSupplyChangeTransactionDTO", EmbeddedMosaicSupplyChangeTransactionDTO.class);
        schemas.put("EmbeddedMosaicSupplyRevocationTransactionDTO", EmbeddedMosaicSupplyRevocationTransactionDTO.class);
        schemas.put("EmbeddedNamespaceRegistrationTransactionDTO", EmbeddedNamespaceRegistrationTransactionDTO.class);
        schemas.put("EmbeddedAddressAliasTransactionDTO", EmbeddedAddressAliasTransactionDTO.class);
        schemas.put("EmbeddedMosaicAliasTransactionDTO", EmbeddedMosaicAliasTransactionDTO.class);
        schemas.put("EmbeddedMultisigAccountModificationTransactionDTO", EmbeddedMultisigAccountModificationTransactionDTO.class);
        schemas.put("EmbeddedAccountAddressRestrictionTransactionDTO", EmbeddedAccountAddressRestrictionTransactionDTO.class);
        schemas.put("EmbeddedAccountMosaicRestrictionTransactionDTO", EmbeddedAccountMosaicRestrictionTransactionDTO.class);
        schemas.put("EmbeddedAccountOperationRestrictionTransactionDTO", EmbeddedAccountOperationRestrictionTransactionDTO.class);
        schemas.put("EmbeddedMosaicGlobalRestrictionTransactionDTO", EmbeddedMosaicGlobalRestrictionTransactionDTO.class);
        schemas.put("EmbeddedMosaicAddressRestrictionTransactionDTO", EmbeddedMosaicAddressRestrictionTransactionDTO.class);
        schemas.put("EmbeddedTransferTransactionDTO", EmbeddedTransferTransactionDTO.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return EmbeddedTransactionInfoDTOTransaction.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO
     *
     * It could be an instance of the 'anyOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof EmbeddedAccountKeyLinkTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedNodeKeyLinkTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedVrfKeyLinkTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedVotingKeyLinkTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedHashLockTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedSecretLockTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedSecretProofTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedAccountMetadataTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicMetadataTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedNamespaceMetadataTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicDefinitionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicSupplyChangeTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicSupplyRevocationTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedNamespaceRegistrationTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedAddressAliasTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicAliasTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMultisigAccountModificationTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedAccountAddressRestrictionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedAccountMosaicRestrictionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedAccountOperationRestrictionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicGlobalRestrictionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedMosaicAddressRestrictionTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof EmbeddedTransferTransactionDTO) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO");
    }

    /**
     * Get the actual instance, which can be the following:
     * EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO
     *
     * @return The actual instance (EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `EmbeddedAccountKeyLinkTransactionDTO`. If the actual instance is not `EmbeddedAccountKeyLinkTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAccountKeyLinkTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAccountKeyLinkTransactionDTO`
     */
    public EmbeddedAccountKeyLinkTransactionDTO getEmbeddedAccountKeyLinkTransactionDTO() throws ClassCastException {
        return (EmbeddedAccountKeyLinkTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedNodeKeyLinkTransactionDTO`. If the actual instance is not `EmbeddedNodeKeyLinkTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedNodeKeyLinkTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedNodeKeyLinkTransactionDTO`
     */
    public EmbeddedNodeKeyLinkTransactionDTO getEmbeddedNodeKeyLinkTransactionDTO() throws ClassCastException {
        return (EmbeddedNodeKeyLinkTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedVrfKeyLinkTransactionDTO`. If the actual instance is not `EmbeddedVrfKeyLinkTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedVrfKeyLinkTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedVrfKeyLinkTransactionDTO`
     */
    public EmbeddedVrfKeyLinkTransactionDTO getEmbeddedVrfKeyLinkTransactionDTO() throws ClassCastException {
        return (EmbeddedVrfKeyLinkTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedVotingKeyLinkTransactionDTO`. If the actual instance is not `EmbeddedVotingKeyLinkTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedVotingKeyLinkTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedVotingKeyLinkTransactionDTO`
     */
    public EmbeddedVotingKeyLinkTransactionDTO getEmbeddedVotingKeyLinkTransactionDTO() throws ClassCastException {
        return (EmbeddedVotingKeyLinkTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedHashLockTransactionDTO`. If the actual instance is not `EmbeddedHashLockTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedHashLockTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedHashLockTransactionDTO`
     */
    public EmbeddedHashLockTransactionDTO getEmbeddedHashLockTransactionDTO() throws ClassCastException {
        return (EmbeddedHashLockTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedSecretLockTransactionDTO`. If the actual instance is not `EmbeddedSecretLockTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedSecretLockTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedSecretLockTransactionDTO`
     */
    public EmbeddedSecretLockTransactionDTO getEmbeddedSecretLockTransactionDTO() throws ClassCastException {
        return (EmbeddedSecretLockTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedSecretProofTransactionDTO`. If the actual instance is not `EmbeddedSecretProofTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedSecretProofTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedSecretProofTransactionDTO`
     */
    public EmbeddedSecretProofTransactionDTO getEmbeddedSecretProofTransactionDTO() throws ClassCastException {
        return (EmbeddedSecretProofTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedAccountMetadataTransactionDTO`. If the actual instance is not `EmbeddedAccountMetadataTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAccountMetadataTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAccountMetadataTransactionDTO`
     */
    public EmbeddedAccountMetadataTransactionDTO getEmbeddedAccountMetadataTransactionDTO() throws ClassCastException {
        return (EmbeddedAccountMetadataTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicMetadataTransactionDTO`. If the actual instance is not `EmbeddedMosaicMetadataTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicMetadataTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicMetadataTransactionDTO`
     */
    public EmbeddedMosaicMetadataTransactionDTO getEmbeddedMosaicMetadataTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicMetadataTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedNamespaceMetadataTransactionDTO`. If the actual instance is not `EmbeddedNamespaceMetadataTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedNamespaceMetadataTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedNamespaceMetadataTransactionDTO`
     */
    public EmbeddedNamespaceMetadataTransactionDTO getEmbeddedNamespaceMetadataTransactionDTO() throws ClassCastException {
        return (EmbeddedNamespaceMetadataTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicDefinitionTransactionDTO`. If the actual instance is not `EmbeddedMosaicDefinitionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicDefinitionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicDefinitionTransactionDTO`
     */
    public EmbeddedMosaicDefinitionTransactionDTO getEmbeddedMosaicDefinitionTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicDefinitionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicSupplyChangeTransactionDTO`. If the actual instance is not `EmbeddedMosaicSupplyChangeTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicSupplyChangeTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicSupplyChangeTransactionDTO`
     */
    public EmbeddedMosaicSupplyChangeTransactionDTO getEmbeddedMosaicSupplyChangeTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicSupplyChangeTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicSupplyRevocationTransactionDTO`. If the actual instance is not `EmbeddedMosaicSupplyRevocationTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicSupplyRevocationTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicSupplyRevocationTransactionDTO`
     */
    public EmbeddedMosaicSupplyRevocationTransactionDTO getEmbeddedMosaicSupplyRevocationTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicSupplyRevocationTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedNamespaceRegistrationTransactionDTO`. If the actual instance is not `EmbeddedNamespaceRegistrationTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedNamespaceRegistrationTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedNamespaceRegistrationTransactionDTO`
     */
    public EmbeddedNamespaceRegistrationTransactionDTO getEmbeddedNamespaceRegistrationTransactionDTO() throws ClassCastException {
        return (EmbeddedNamespaceRegistrationTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedAddressAliasTransactionDTO`. If the actual instance is not `EmbeddedAddressAliasTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAddressAliasTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAddressAliasTransactionDTO`
     */
    public EmbeddedAddressAliasTransactionDTO getEmbeddedAddressAliasTransactionDTO() throws ClassCastException {
        return (EmbeddedAddressAliasTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicAliasTransactionDTO`. If the actual instance is not `EmbeddedMosaicAliasTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicAliasTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicAliasTransactionDTO`
     */
    public EmbeddedMosaicAliasTransactionDTO getEmbeddedMosaicAliasTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicAliasTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMultisigAccountModificationTransactionDTO`. If the actual instance is not `EmbeddedMultisigAccountModificationTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMultisigAccountModificationTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMultisigAccountModificationTransactionDTO`
     */
    public EmbeddedMultisigAccountModificationTransactionDTO getEmbeddedMultisigAccountModificationTransactionDTO() throws ClassCastException {
        return (EmbeddedMultisigAccountModificationTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedAccountAddressRestrictionTransactionDTO`. If the actual instance is not `EmbeddedAccountAddressRestrictionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAccountAddressRestrictionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAccountAddressRestrictionTransactionDTO`
     */
    public EmbeddedAccountAddressRestrictionTransactionDTO getEmbeddedAccountAddressRestrictionTransactionDTO() throws ClassCastException {
        return (EmbeddedAccountAddressRestrictionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedAccountMosaicRestrictionTransactionDTO`. If the actual instance is not `EmbeddedAccountMosaicRestrictionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAccountMosaicRestrictionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAccountMosaicRestrictionTransactionDTO`
     */
    public EmbeddedAccountMosaicRestrictionTransactionDTO getEmbeddedAccountMosaicRestrictionTransactionDTO() throws ClassCastException {
        return (EmbeddedAccountMosaicRestrictionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedAccountOperationRestrictionTransactionDTO`. If the actual instance is not `EmbeddedAccountOperationRestrictionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedAccountOperationRestrictionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedAccountOperationRestrictionTransactionDTO`
     */
    public EmbeddedAccountOperationRestrictionTransactionDTO getEmbeddedAccountOperationRestrictionTransactionDTO() throws ClassCastException {
        return (EmbeddedAccountOperationRestrictionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicGlobalRestrictionTransactionDTO`. If the actual instance is not `EmbeddedMosaicGlobalRestrictionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicGlobalRestrictionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicGlobalRestrictionTransactionDTO`
     */
    public EmbeddedMosaicGlobalRestrictionTransactionDTO getEmbeddedMosaicGlobalRestrictionTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicGlobalRestrictionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedMosaicAddressRestrictionTransactionDTO`. If the actual instance is not `EmbeddedMosaicAddressRestrictionTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedMosaicAddressRestrictionTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedMosaicAddressRestrictionTransactionDTO`
     */
    public EmbeddedMosaicAddressRestrictionTransactionDTO getEmbeddedMosaicAddressRestrictionTransactionDTO() throws ClassCastException {
        return (EmbeddedMosaicAddressRestrictionTransactionDTO)super.getActualInstance();
    }
    /**
     * Get the actual instance of `EmbeddedTransferTransactionDTO`. If the actual instance is not `EmbeddedTransferTransactionDTO`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EmbeddedTransferTransactionDTO`
     * @throws ClassCastException if the instance is not `EmbeddedTransferTransactionDTO`
     */
    public EmbeddedTransferTransactionDTO getEmbeddedTransferTransactionDTO() throws ClassCastException {
        return (EmbeddedTransferTransactionDTO)super.getActualInstance();
    }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to EmbeddedTransactionInfoDTOTransaction
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    // validate anyOf schemas one by one
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with EmbeddedAccountKeyLinkTransactionDTO
    try {
      EmbeddedAccountKeyLinkTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAccountKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedNodeKeyLinkTransactionDTO
    try {
      EmbeddedNodeKeyLinkTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedNodeKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedVrfKeyLinkTransactionDTO
    try {
      EmbeddedVrfKeyLinkTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedVrfKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedVotingKeyLinkTransactionDTO
    try {
      EmbeddedVotingKeyLinkTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedVotingKeyLinkTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedHashLockTransactionDTO
    try {
      EmbeddedHashLockTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedHashLockTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedSecretLockTransactionDTO
    try {
      EmbeddedSecretLockTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedSecretLockTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedSecretProofTransactionDTO
    try {
      EmbeddedSecretProofTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedSecretProofTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedAccountMetadataTransactionDTO
    try {
      EmbeddedAccountMetadataTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAccountMetadataTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicMetadataTransactionDTO
    try {
      EmbeddedMosaicMetadataTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicMetadataTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedNamespaceMetadataTransactionDTO
    try {
      EmbeddedNamespaceMetadataTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedNamespaceMetadataTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicDefinitionTransactionDTO
    try {
      EmbeddedMosaicDefinitionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicDefinitionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicSupplyChangeTransactionDTO
    try {
      EmbeddedMosaicSupplyChangeTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicSupplyChangeTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicSupplyRevocationTransactionDTO
    try {
      EmbeddedMosaicSupplyRevocationTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicSupplyRevocationTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedNamespaceRegistrationTransactionDTO
    try {
      EmbeddedNamespaceRegistrationTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedNamespaceRegistrationTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedAddressAliasTransactionDTO
    try {
      EmbeddedAddressAliasTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAddressAliasTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicAliasTransactionDTO
    try {
      EmbeddedMosaicAliasTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicAliasTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMultisigAccountModificationTransactionDTO
    try {
      EmbeddedMultisigAccountModificationTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMultisigAccountModificationTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedAccountAddressRestrictionTransactionDTO
    try {
      EmbeddedAccountAddressRestrictionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAccountAddressRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedAccountMosaicRestrictionTransactionDTO
    try {
      EmbeddedAccountMosaicRestrictionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAccountMosaicRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedAccountOperationRestrictionTransactionDTO
    try {
      EmbeddedAccountOperationRestrictionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedAccountOperationRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicGlobalRestrictionTransactionDTO
    try {
      EmbeddedMosaicGlobalRestrictionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicGlobalRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedMosaicAddressRestrictionTransactionDTO
    try {
      EmbeddedMosaicAddressRestrictionTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedMosaicAddressRestrictionTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with EmbeddedTransferTransactionDTO
    try {
      EmbeddedTransferTransactionDTO.validateJsonElement(jsonElement);
      return;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for EmbeddedTransferTransactionDTO failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    throw new IOException(String.format("The JSON string is invalid for EmbeddedTransactionInfoDTOTransaction with anyOf schemas: EmbeddedAccountAddressRestrictionTransactionDTO, EmbeddedAccountKeyLinkTransactionDTO, EmbeddedAccountMetadataTransactionDTO, EmbeddedAccountMosaicRestrictionTransactionDTO, EmbeddedAccountOperationRestrictionTransactionDTO, EmbeddedAddressAliasTransactionDTO, EmbeddedHashLockTransactionDTO, EmbeddedMosaicAddressRestrictionTransactionDTO, EmbeddedMosaicAliasTransactionDTO, EmbeddedMosaicDefinitionTransactionDTO, EmbeddedMosaicGlobalRestrictionTransactionDTO, EmbeddedMosaicMetadataTransactionDTO, EmbeddedMosaicSupplyChangeTransactionDTO, EmbeddedMosaicSupplyRevocationTransactionDTO, EmbeddedMultisigAccountModificationTransactionDTO, EmbeddedNamespaceMetadataTransactionDTO, EmbeddedNamespaceRegistrationTransactionDTO, EmbeddedNodeKeyLinkTransactionDTO, EmbeddedSecretLockTransactionDTO, EmbeddedSecretProofTransactionDTO, EmbeddedTransferTransactionDTO, EmbeddedVotingKeyLinkTransactionDTO, EmbeddedVrfKeyLinkTransactionDTO. no class match the result, expected at least 1. Detailed failure message for anyOf schemas: %s. JSON: %s", errorMessages, jsonElement.toString()));
    
  }

 /**
  * Create an instance of EmbeddedTransactionInfoDTOTransaction given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of EmbeddedTransactionInfoDTOTransaction
  * @throws IOException if the JSON string is invalid with respect to EmbeddedTransactionInfoDTOTransaction
  */
  public static EmbeddedTransactionInfoDTOTransaction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EmbeddedTransactionInfoDTOTransaction.class);
  }

 /**
  * Convert an instance of EmbeddedTransactionInfoDTOTransaction to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

