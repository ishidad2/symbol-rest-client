//
// BlockDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct BlockDTO: Codable, JSONEncodable, Hashable {

    /** A number that allows uint 32 values. */
    public var size: Int64
    /** Entity's signature generated by the signer. */
    public var signature: String
    /** Public key. */
    public var signerPublicKey: String
    /** Entity version. */
    public var version: Int
    public var network: NetworkTypeEnum
    public var type: Int
    /** Height of the blockchain. */
    public var height: String
    /** Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network's 'epochAdjustment'. */
    public var timestamp: String
    /** Determines how hard is to harvest a new block, based on previous blocks. */
    public var difficulty: String
    /** 32-bytes VRF proof gamma. */
    public var proofGamma: String
    /** 16-bytes VRF proof verification hash. */
    public var proofVerificationHash: String
    /** 32-bytes VRF proof scalar. */
    public var proofScalar: String
    public var previousBlockHash: String
    public var transactionsHash: String
    public var receiptsHash: String
    public var stateHash: String
    /** Address encoded using a 32-character set. */
    public var beneficiaryAddress: String
    /** Fee multiplier applied to transactions contained in block. */
    public var feeMultiplier: Int64

    public init(size: Int64, signature: String, signerPublicKey: String, version: Int, network: NetworkTypeEnum, type: Int, height: String, timestamp: String, difficulty: String, proofGamma: String, proofVerificationHash: String, proofScalar: String, previousBlockHash: String, transactionsHash: String, receiptsHash: String, stateHash: String, beneficiaryAddress: String, feeMultiplier: Int64) {
        self.size = size
        self.signature = signature
        self.signerPublicKey = signerPublicKey
        self.version = version
        self.network = network
        self.type = type
        self.height = height
        self.timestamp = timestamp
        self.difficulty = difficulty
        self.proofGamma = proofGamma
        self.proofVerificationHash = proofVerificationHash
        self.proofScalar = proofScalar
        self.previousBlockHash = previousBlockHash
        self.transactionsHash = transactionsHash
        self.receiptsHash = receiptsHash
        self.stateHash = stateHash
        self.beneficiaryAddress = beneficiaryAddress
        self.feeMultiplier = feeMultiplier
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case size
        case signature
        case signerPublicKey
        case version
        case network
        case type
        case height
        case timestamp
        case difficulty
        case proofGamma
        case proofVerificationHash
        case proofScalar
        case previousBlockHash
        case transactionsHash
        case receiptsHash
        case stateHash
        case beneficiaryAddress
        case feeMultiplier
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(size, forKey: .size)
        try container.encode(signature, forKey: .signature)
        try container.encode(signerPublicKey, forKey: .signerPublicKey)
        try container.encode(version, forKey: .version)
        try container.encode(network, forKey: .network)
        try container.encode(type, forKey: .type)
        try container.encode(height, forKey: .height)
        try container.encode(timestamp, forKey: .timestamp)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(proofGamma, forKey: .proofGamma)
        try container.encode(proofVerificationHash, forKey: .proofVerificationHash)
        try container.encode(proofScalar, forKey: .proofScalar)
        try container.encode(previousBlockHash, forKey: .previousBlockHash)
        try container.encode(transactionsHash, forKey: .transactionsHash)
        try container.encode(receiptsHash, forKey: .receiptsHash)
        try container.encode(stateHash, forKey: .stateHash)
        try container.encode(beneficiaryAddress, forKey: .beneficiaryAddress)
        try container.encode(feeMultiplier, forKey: .feeMultiplier)
    }
}

