//
// NamespaceNetworkPropertiesDTO.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct NamespaceNetworkPropertiesDTO: Codable, JSONEncodable, Hashable {

    /** Maximum namespace name size. */
    public var maxNameSize: String?
    /** Maximum number of children for a root namespace. */
    public var maxChildNamespaces: String?
    /** Maximum namespace depth. */
    public var maxNamespaceDepth: String?
    /** Minimum namespace duration. */
    public var minNamespaceDuration: String?
    /** Maximum namespace duration. */
    public var maxNamespaceDuration: String?
    /** Grace period during which time only the previous owner can renew an expired namespace. */
    public var namespaceGracePeriodDuration: String?
    /** Reserved root namespaces that cannot be claimed. */
    public var reservedRootNamespaceNames: String?
    /** Address encoded using a 32-character set. */
    public var namespaceRentalFeeSinkAddress: String?
    /** Root namespace rental fee per block. */
    public var rootNamespaceRentalFeePerBlock: String?
    /** Child namespace rental fee. */
    public var childNamespaceRentalFee: String?

    public init(maxNameSize: String? = nil, maxChildNamespaces: String? = nil, maxNamespaceDepth: String? = nil, minNamespaceDuration: String? = nil, maxNamespaceDuration: String? = nil, namespaceGracePeriodDuration: String? = nil, reservedRootNamespaceNames: String? = nil, namespaceRentalFeeSinkAddress: String? = nil, rootNamespaceRentalFeePerBlock: String? = nil, childNamespaceRentalFee: String? = nil) {
        self.maxNameSize = maxNameSize
        self.maxChildNamespaces = maxChildNamespaces
        self.maxNamespaceDepth = maxNamespaceDepth
        self.minNamespaceDuration = minNamespaceDuration
        self.maxNamespaceDuration = maxNamespaceDuration
        self.namespaceGracePeriodDuration = namespaceGracePeriodDuration
        self.reservedRootNamespaceNames = reservedRootNamespaceNames
        self.namespaceRentalFeeSinkAddress = namespaceRentalFeeSinkAddress
        self.rootNamespaceRentalFeePerBlock = rootNamespaceRentalFeePerBlock
        self.childNamespaceRentalFee = childNamespaceRentalFee
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case maxNameSize
        case maxChildNamespaces
        case maxNamespaceDepth
        case minNamespaceDuration
        case maxNamespaceDuration
        case namespaceGracePeriodDuration
        case reservedRootNamespaceNames
        case namespaceRentalFeeSinkAddress
        case rootNamespaceRentalFeePerBlock
        case childNamespaceRentalFee
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(maxNameSize, forKey: .maxNameSize)
        try container.encodeIfPresent(maxChildNamespaces, forKey: .maxChildNamespaces)
        try container.encodeIfPresent(maxNamespaceDepth, forKey: .maxNamespaceDepth)
        try container.encodeIfPresent(minNamespaceDuration, forKey: .minNamespaceDuration)
        try container.encodeIfPresent(maxNamespaceDuration, forKey: .maxNamespaceDuration)
        try container.encodeIfPresent(namespaceGracePeriodDuration, forKey: .namespaceGracePeriodDuration)
        try container.encodeIfPresent(reservedRootNamespaceNames, forKey: .reservedRootNamespaceNames)
        try container.encodeIfPresent(namespaceRentalFeeSinkAddress, forKey: .namespaceRentalFeeSinkAddress)
        try container.encodeIfPresent(rootNamespaceRentalFeePerBlock, forKey: .rootNamespaceRentalFeePerBlock)
        try container.encodeIfPresent(childNamespaceRentalFee, forKey: .childNamespaceRentalFee)
    }
}

