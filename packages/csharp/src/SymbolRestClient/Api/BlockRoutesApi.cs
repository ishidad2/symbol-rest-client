/*
 * Catapult REST Endpoints
 *
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using SymbolRestClient.Client;
using SymbolRestClient.Model;

namespace SymbolRestClient.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBlockRoutesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BlockInfoDTO</returns>
        BlockInfoDTO GetBlockByHeight(string height, int operationIndex = 0);

        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BlockInfoDTO</returns>
        ApiResponse<BlockInfoDTO> GetBlockByHeightWithHttpInfo(string height, int operationIndex = 0);
        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        MerkleProofInfoDTO GetMerkleReceipts(string height, string hash, int operationIndex = 0);

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        ApiResponse<MerkleProofInfoDTO> GetMerkleReceiptsWithHttpInfo(string height, string hash, int operationIndex = 0);
        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        MerkleProofInfoDTO GetMerkleTransaction(string height, string hash, int operationIndex = 0);

        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        ApiResponse<MerkleProofInfoDTO> GetMerkleTransactionWithHttpInfo(string height, string hash, int operationIndex = 0);
        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BlockPage</returns>
        BlockPage SearchBlocks(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0);

        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BlockPage</returns>
        ApiResponse<BlockPage> SearchBlocksWithHttpInfo(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBlockRoutesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BlockInfoDTO</returns>
        System.Threading.Tasks.Task<BlockInfoDTO> GetBlockByHeightAsync(string height, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get block information
        /// </summary>
        /// <remarks>
        /// Gets a block from the chain that has the given height.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BlockInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<BlockInfoDTO>> GetBlockByHeightWithHttpInfoAsync(string height, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleReceiptsAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleReceiptsWithHttpInfoAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleTransactionAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get the merkle path for a given a transaction and block
        /// </summary>
        /// <remarks>
        /// Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        System.Threading.Tasks.Task<ApiResponse<MerkleProofInfoDTO>> GetMerkleTransactionWithHttpInfoAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BlockPage</returns>
        System.Threading.Tasks.Task<BlockPage> SearchBlocksAsync(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search blocks
        /// </summary>
        /// <remarks>
        /// Gets an array of bocks.
        /// </remarks>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BlockPage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BlockPage>> SearchBlocksWithHttpInfoAsync(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBlockRoutesApi : IBlockRoutesApiSync, IBlockRoutesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BlockRoutesApi : IBlockRoutesApi
    {
        private SymbolRestClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BlockRoutesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BlockRoutesApi(string basePath)
        {
            this.Configuration = SymbolRestClient.Client.Configuration.MergeConfigurations(
                SymbolRestClient.Client.GlobalConfiguration.Instance,
                new SymbolRestClient.Client.Configuration { BasePath = basePath }
            );
            this.Client = new SymbolRestClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new SymbolRestClient.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = SymbolRestClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public BlockRoutesApi(SymbolRestClient.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = SymbolRestClient.Client.Configuration.MergeConfigurations(
                SymbolRestClient.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new SymbolRestClient.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new SymbolRestClient.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = SymbolRestClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockRoutesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public BlockRoutesApi(SymbolRestClient.Client.ISynchronousClient client, SymbolRestClient.Client.IAsynchronousClient asyncClient, SymbolRestClient.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = SymbolRestClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public SymbolRestClient.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public SymbolRestClient.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public SymbolRestClient.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public SymbolRestClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BlockInfoDTO</returns>
        public BlockInfoDTO GetBlockByHeight(string height, int operationIndex = 0)
        {
            SymbolRestClient.Client.ApiResponse<BlockInfoDTO> localVarResponse = GetBlockByHeightWithHttpInfo(height);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BlockInfoDTO</returns>
        public SymbolRestClient.Client.ApiResponse<BlockInfoDTO> GetBlockByHeightWithHttpInfo(string height, int operationIndex = 0)
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetBlockByHeight");
            }

            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetBlockByHeight";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<BlockInfoDTO>("/blocks/{height}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBlockByHeight", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BlockInfoDTO</returns>
        public async System.Threading.Tasks.Task<BlockInfoDTO> GetBlockByHeightAsync(string height, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            SymbolRestClient.Client.ApiResponse<BlockInfoDTO> localVarResponse = await GetBlockByHeightWithHttpInfoAsync(height, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get block information Gets a block from the chain that has the given height.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BlockInfoDTO)</returns>
        public async System.Threading.Tasks.Task<SymbolRestClient.Client.ApiResponse<BlockInfoDTO>> GetBlockByHeightWithHttpInfoAsync(string height, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetBlockByHeight");
            }


            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetBlockByHeight";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<BlockInfoDTO>("/blocks/{height}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBlockByHeight", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        public MerkleProofInfoDTO GetMerkleReceipts(string height, string hash, int operationIndex = 0)
        {
            SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> localVarResponse = GetMerkleReceiptsWithHttpInfo(height, hash);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        public SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> GetMerkleReceiptsWithHttpInfo(string height, string hash, int operationIndex = 0)
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleReceipts");
            }

            // verify the required parameter 'hash' is set
            if (hash == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleReceipts");
            }

            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter
            localVarRequestOptions.PathParameters.Add("hash", SymbolRestClient.Client.ClientUtils.ParameterToString(hash)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetMerkleReceipts";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<MerkleProofInfoDTO>("/blocks/{height}/statements/{hash}/merkle", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMerkleReceipts", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        public async System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleReceiptsAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> localVarResponse = await GetMerkleReceiptsWithHttpInfoAsync(height, hash, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a receipt statement hash and block Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Receipt hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        public async System.Threading.Tasks.Task<SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO>> GetMerkleReceiptsWithHttpInfoAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleReceipts");
            }

            // verify the required parameter 'hash' is set
            if (hash == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleReceipts");
            }


            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter
            localVarRequestOptions.PathParameters.Add("hash", SymbolRestClient.Client.ClientUtils.ParameterToString(hash)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetMerkleReceipts";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<MerkleProofInfoDTO>("/blocks/{height}/statements/{hash}/merkle", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMerkleReceipts", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>MerkleProofInfoDTO</returns>
        public MerkleProofInfoDTO GetMerkleTransaction(string height, string hash, int operationIndex = 0)
        {
            SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> localVarResponse = GetMerkleTransactionWithHttpInfo(height, hash);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of MerkleProofInfoDTO</returns>
        public SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> GetMerkleTransactionWithHttpInfo(string height, string hash, int operationIndex = 0)
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleTransaction");
            }

            // verify the required parameter 'hash' is set
            if (hash == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleTransaction");
            }

            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter
            localVarRequestOptions.PathParameters.Add("hash", SymbolRestClient.Client.ClientUtils.ParameterToString(hash)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetMerkleTransaction";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<MerkleProofInfoDTO>("/blocks/{height}/transactions/{hash}/merkle", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMerkleTransaction", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MerkleProofInfoDTO</returns>
        public async System.Threading.Tasks.Task<MerkleProofInfoDTO> GetMerkleTransactionAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO> localVarResponse = await GetMerkleTransactionWithHttpInfoAsync(height, hash, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the merkle path for a given a transaction and block Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash &#x3D; hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position &#x3D;&#x3D; left -&gt; proofHash &#x3D; sha_256(item.hash + proofHash). * b) If item.position &#x3D;&#x3D; right -&gt; proofHash &#x3D; sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="height">Block height.</param>
        /// <param name="hash">Transaction hash.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MerkleProofInfoDTO)</returns>
        public async System.Threading.Tasks.Task<SymbolRestClient.Client.ApiResponse<MerkleProofInfoDTO>> GetMerkleTransactionWithHttpInfoAsync(string height, string hash, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'height' is set
            if (height == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'height' when calling BlockRoutesApi->GetMerkleTransaction");
            }

            // verify the required parameter 'hash' is set
            if (hash == null)
            {
                throw new SymbolRestClient.Client.ApiException(400, "Missing required parameter 'hash' when calling BlockRoutesApi->GetMerkleTransaction");
            }


            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("height", SymbolRestClient.Client.ClientUtils.ParameterToString(height)); // path parameter
            localVarRequestOptions.PathParameters.Add("hash", SymbolRestClient.Client.ClientUtils.ParameterToString(hash)); // path parameter

            localVarRequestOptions.Operation = "BlockRoutesApi.GetMerkleTransaction";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<MerkleProofInfoDTO>("/blocks/{height}/transactions/{hash}/merkle", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMerkleTransaction", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BlockPage</returns>
        public BlockPage SearchBlocks(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0)
        {
            SymbolRestClient.Client.ApiResponse<BlockPage> localVarResponse = SearchBlocksWithHttpInfo(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BlockPage</returns>
        public SymbolRestClient.Client.ApiResponse<BlockPage> SearchBlocksWithHttpInfo(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0)
        {
            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (signerPublicKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "signerPublicKey", signerPublicKey));
            }
            if (beneficiaryAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "beneficiaryAddress", beneficiaryAddress));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            if (pageNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "pageNumber", pageNumber));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (orderBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "orderBy", orderBy));
            }

            localVarRequestOptions.Operation = "BlockRoutesApi.SearchBlocks";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<BlockPage>("/blocks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchBlocks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BlockPage</returns>
        public async System.Threading.Tasks.Task<BlockPage> SearchBlocksAsync(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            SymbolRestClient.Client.ApiResponse<BlockPage> localVarResponse = await SearchBlocksWithHttpInfoAsync(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search blocks Gets an array of bocks.
        /// </summary>
        /// <exception cref="SymbolRestClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signerPublicKey">Filter by public key of the account signing the entity. (optional)</param>
        /// <param name="beneficiaryAddress">Filter by beneficiary address. (optional)</param>
        /// <param name="pageSize">Select the number of entries to return. (optional, default to 10)</param>
        /// <param name="pageNumber">Filter by page number. (optional, default to 1)</param>
        /// <param name="offset">Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.  (optional)</param>
        /// <param name="order">Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.  (optional)</param>
        /// <param name="orderBy">Sort responses by the property set.  (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BlockPage)</returns>
        public async System.Threading.Tasks.Task<SymbolRestClient.Client.ApiResponse<BlockPage>> SearchBlocksWithHttpInfoAsync(string? signerPublicKey = default(string?), string? beneficiaryAddress = default(string?), int? pageSize = default(int?), int? pageNumber = default(int?), string? offset = default(string?), Order? order = default(Order?), BlockOrderByEnum? orderBy = default(BlockOrderByEnum?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            SymbolRestClient.Client.RequestOptions localVarRequestOptions = new SymbolRestClient.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = SymbolRestClient.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = SymbolRestClient.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (signerPublicKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "signerPublicKey", signerPublicKey));
            }
            if (beneficiaryAddress != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "beneficiaryAddress", beneficiaryAddress));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            }
            if (pageNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "pageNumber", pageNumber));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (orderBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(SymbolRestClient.Client.ClientUtils.ParameterToMultiMap("", "orderBy", orderBy));
            }

            localVarRequestOptions.Operation = "BlockRoutesApi.SearchBlocks";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<BlockPage>("/blocks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchBlocks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
