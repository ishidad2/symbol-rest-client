/*
Catapult REST Endpoints

OpenAPI Specification of catapult-rest

API version: 1.0.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TransactionRoutesAPIService TransactionRoutesAPI service
type TransactionRoutesAPIService service

type ApiAnnounceCosignatureTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	cosignature *Cosignature
}

func (r ApiAnnounceCosignatureTransactionRequest) Cosignature(cosignature Cosignature) ApiAnnounceCosignatureTransactionRequest {
	r.cosignature = &cosignature
	return r
}

func (r ApiAnnounceCosignatureTransactionRequest) Execute() (*AnnounceTransactionInfoDTO, *http.Response, error) {
	return r.ApiService.AnnounceCosignatureTransactionExecute(r)
}

/*
AnnounceCosignatureTransaction Announce a cosignature transaction

Announces a cosignature transaction to the network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnounceCosignatureTransactionRequest
*/
func (a *TransactionRoutesAPIService) AnnounceCosignatureTransaction(ctx context.Context) ApiAnnounceCosignatureTransactionRequest {
	return ApiAnnounceCosignatureTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnnounceTransactionInfoDTO
func (a *TransactionRoutesAPIService) AnnounceCosignatureTransactionExecute(r ApiAnnounceCosignatureTransactionRequest) (*AnnounceTransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnnounceTransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.AnnounceCosignatureTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/cosignature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cosignature == nil {
		return localVarReturnValue, nil, reportError("cosignature is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cosignature
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnouncePartialTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionPayload *TransactionPayload
}

func (r ApiAnnouncePartialTransactionRequest) TransactionPayload(transactionPayload TransactionPayload) ApiAnnouncePartialTransactionRequest {
	r.transactionPayload = &transactionPayload
	return r
}

func (r ApiAnnouncePartialTransactionRequest) Execute() (*AnnounceTransactionInfoDTO, *http.Response, error) {
	return r.ApiService.AnnouncePartialTransactionExecute(r)
}

/*
AnnouncePartialTransaction Announce an aggregate bonded transaction

Announces an aggregate bonded transaction to the network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnouncePartialTransactionRequest
*/
func (a *TransactionRoutesAPIService) AnnouncePartialTransaction(ctx context.Context) ApiAnnouncePartialTransactionRequest {
	return ApiAnnouncePartialTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnnounceTransactionInfoDTO
func (a *TransactionRoutesAPIService) AnnouncePartialTransactionExecute(r ApiAnnouncePartialTransactionRequest) (*AnnounceTransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnnounceTransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.AnnouncePartialTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/partial"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionPayload == nil {
		return localVarReturnValue, nil, reportError("transactionPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnounceTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionPayload *TransactionPayload
}

func (r ApiAnnounceTransactionRequest) TransactionPayload(transactionPayload TransactionPayload) ApiAnnounceTransactionRequest {
	r.transactionPayload = &transactionPayload
	return r
}

func (r ApiAnnounceTransactionRequest) Execute() (*AnnounceTransactionInfoDTO, *http.Response, error) {
	return r.ApiService.AnnounceTransactionExecute(r)
}

/*
AnnounceTransaction Announce a new transaction

Announces a transaction to the network.
The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities.
Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html). 
It's recommended to use SDKs instead of calling the API endpoint directly to announce transactions.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnounceTransactionRequest
*/
func (a *TransactionRoutesAPIService) AnnounceTransaction(ctx context.Context) ApiAnnounceTransactionRequest {
	return ApiAnnounceTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnnounceTransactionInfoDTO
func (a *TransactionRoutesAPIService) AnnounceTransactionExecute(r ApiAnnounceTransactionRequest) (*AnnounceTransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnnounceTransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.AnnounceTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionPayload == nil {
		return localVarReturnValue, nil, reportError("transactionPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfirmedTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionId string
}

func (r ApiGetConfirmedTransactionRequest) Execute() (*TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetConfirmedTransactionExecute(r)
}

/*
GetConfirmedTransaction Get confirmed transaction information

Returns confirmed transaction information given a transactionId or hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Transaction id or hash.
 @return ApiGetConfirmedTransactionRequest
*/
func (a *TransactionRoutesAPIService) GetConfirmedTransaction(ctx context.Context, transactionId string) ApiGetConfirmedTransactionRequest {
	return ApiGetConfirmedTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetConfirmedTransactionExecute(r ApiGetConfirmedTransactionRequest) (*TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetConfirmedTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/confirmed/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfirmedTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionIds *TransactionIds
}

func (r ApiGetConfirmedTransactionsRequest) TransactionIds(transactionIds TransactionIds) ApiGetConfirmedTransactionsRequest {
	r.transactionIds = &transactionIds
	return r
}

func (r ApiGetConfirmedTransactionsRequest) Execute() ([]TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetConfirmedTransactionsExecute(r)
}

/*
GetConfirmedTransactions Get confirmed trasactions information

Returns confirmed transactions information for a given array of transactionIds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfirmedTransactionsRequest
*/
func (a *TransactionRoutesAPIService) GetConfirmedTransactions(ctx context.Context) ApiGetConfirmedTransactionsRequest {
	return ApiGetConfirmedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetConfirmedTransactionsExecute(r ApiGetConfirmedTransactionsRequest) ([]TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetConfirmedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/confirmed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionIds == nil {
		return localVarReturnValue, nil, reportError("transactionIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartialTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionId string
}

func (r ApiGetPartialTransactionRequest) Execute() (*TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetPartialTransactionExecute(r)
}

/*
GetPartialTransaction Get partial transaction information

Returns partial transaction information given a transactionId or hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Transaction id or hash.
 @return ApiGetPartialTransactionRequest
*/
func (a *TransactionRoutesAPIService) GetPartialTransaction(ctx context.Context, transactionId string) ApiGetPartialTransactionRequest {
	return ApiGetPartialTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetPartialTransactionExecute(r ApiGetPartialTransactionRequest) (*TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetPartialTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/partial/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartialTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionIds *TransactionIds
}

func (r ApiGetPartialTransactionsRequest) TransactionIds(transactionIds TransactionIds) ApiGetPartialTransactionsRequest {
	r.transactionIds = &transactionIds
	return r
}

func (r ApiGetPartialTransactionsRequest) Execute() ([]TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetPartialTransactionsExecute(r)
}

/*
GetPartialTransactions Get partial trasactions information

Returns partial transactions information for a given array of transactionIds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPartialTransactionsRequest
*/
func (a *TransactionRoutesAPIService) GetPartialTransactions(ctx context.Context) ApiGetPartialTransactionsRequest {
	return ApiGetPartialTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetPartialTransactionsExecute(r ApiGetPartialTransactionsRequest) ([]TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetPartialTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/partial"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionIds == nil {
		return localVarReturnValue, nil, reportError("transactionIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnconfirmedTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionId string
}

func (r ApiGetUnconfirmedTransactionRequest) Execute() (*TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetUnconfirmedTransactionExecute(r)
}

/*
GetUnconfirmedTransaction Get unconfirmed transaction information

Returns unconfirmed transaction information given a transactionId or hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId Transaction id or hash.
 @return ApiGetUnconfirmedTransactionRequest
*/
func (a *TransactionRoutesAPIService) GetUnconfirmedTransaction(ctx context.Context, transactionId string) ApiGetUnconfirmedTransactionRequest {
	return ApiGetUnconfirmedTransactionRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetUnconfirmedTransactionExecute(r ApiGetUnconfirmedTransactionRequest) (*TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetUnconfirmedTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/unconfirmed/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnconfirmedTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	transactionIds *TransactionIds
}

func (r ApiGetUnconfirmedTransactionsRequest) TransactionIds(transactionIds TransactionIds) ApiGetUnconfirmedTransactionsRequest {
	r.transactionIds = &transactionIds
	return r
}

func (r ApiGetUnconfirmedTransactionsRequest) Execute() ([]TransactionInfoDTO, *http.Response, error) {
	return r.ApiService.GetUnconfirmedTransactionsExecute(r)
}

/*
GetUnconfirmedTransactions Get unconfirmed trasactions information

Returns unconfirmed transactions information for a given array of transactionIds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnconfirmedTransactionsRequest
*/
func (a *TransactionRoutesAPIService) GetUnconfirmedTransactions(ctx context.Context) ApiGetUnconfirmedTransactionsRequest {
	return ApiGetUnconfirmedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TransactionInfoDTO
func (a *TransactionRoutesAPIService) GetUnconfirmedTransactionsExecute(r ApiGetUnconfirmedTransactionsRequest) ([]TransactionInfoDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TransactionInfoDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.GetUnconfirmedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/unconfirmed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionIds == nil {
		return localVarReturnValue, nil, reportError("transactionIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchConfirmedTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	address *string
	recipientAddress *string
	signerPublicKey *string
	height *string
	fromHeight *string
	toHeight *string
	fromTransferAmount *string
	toTransferAmount *string
	type_ *[]TransactionTypeEnum
	embedded *bool
	transferMosaicId *string
	pageSize *int32
	pageNumber *int32
	offset *string
	order *Order
}

// Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
func (r ApiSearchConfirmedTransactionsRequest) Address(address string) ApiSearchConfirmedTransactionsRequest {
	r.address = &address
	return r
}

// Filter by address of the account receiving the transaction.
func (r ApiSearchConfirmedTransactionsRequest) RecipientAddress(recipientAddress string) ApiSearchConfirmedTransactionsRequest {
	r.recipientAddress = &recipientAddress
	return r
}

// Filter by public key of the account signing the entity.
func (r ApiSearchConfirmedTransactionsRequest) SignerPublicKey(signerPublicKey string) ApiSearchConfirmedTransactionsRequest {
	r.signerPublicKey = &signerPublicKey
	return r
}

// Filter by block height.
func (r ApiSearchConfirmedTransactionsRequest) Height(height string) ApiSearchConfirmedTransactionsRequest {
	r.height = &height
	return r
}

// Only blocks with height greater or equal than this one are returned.
func (r ApiSearchConfirmedTransactionsRequest) FromHeight(fromHeight string) ApiSearchConfirmedTransactionsRequest {
	r.fromHeight = &fromHeight
	return r
}

// Only blocks with height smaller or equal than this one are returned.
func (r ApiSearchConfirmedTransactionsRequest) ToHeight(toHeight string) ApiSearchConfirmedTransactionsRequest {
	r.toHeight = &toHeight
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
func (r ApiSearchConfirmedTransactionsRequest) FromTransferAmount(fromTransferAmount string) ApiSearchConfirmedTransactionsRequest {
	r.fromTransferAmount = &fromTransferAmount
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
func (r ApiSearchConfirmedTransactionsRequest) ToTransferAmount(toTransferAmount string) ApiSearchConfirmedTransactionsRequest {
	r.toTransferAmount = &toTransferAmount
	return r
}

// Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
func (r ApiSearchConfirmedTransactionsRequest) Type_(type_ []TransactionTypeEnum) ApiSearchConfirmedTransactionsRequest {
	r.type_ = &type_
	return r
}

// When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
func (r ApiSearchConfirmedTransactionsRequest) Embedded(embedded bool) ApiSearchConfirmedTransactionsRequest {
	r.embedded = &embedded
	return r
}

// Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
func (r ApiSearchConfirmedTransactionsRequest) TransferMosaicId(transferMosaicId string) ApiSearchConfirmedTransactionsRequest {
	r.transferMosaicId = &transferMosaicId
	return r
}

// Select the number of entries to return.
func (r ApiSearchConfirmedTransactionsRequest) PageSize(pageSize int32) ApiSearchConfirmedTransactionsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by page number.
func (r ApiSearchConfirmedTransactionsRequest) PageNumber(pageNumber int32) ApiSearchConfirmedTransactionsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
func (r ApiSearchConfirmedTransactionsRequest) Offset(offset string) ApiSearchConfirmedTransactionsRequest {
	r.offset = &offset
	return r
}

// Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
func (r ApiSearchConfirmedTransactionsRequest) Order(order Order) ApiSearchConfirmedTransactionsRequest {
	r.order = &order
	return r
}

func (r ApiSearchConfirmedTransactionsRequest) Execute() (*TransactionPage, *http.Response, error) {
	return r.ApiService.SearchConfirmedTransactionsExecute(r)
}

/*
SearchConfirmedTransactions Search confirmed transactions

Returns an array of confirmed transactions.
If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that
was resolved from the alias at confirmation time.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchConfirmedTransactionsRequest
*/
func (a *TransactionRoutesAPIService) SearchConfirmedTransactions(ctx context.Context) ApiSearchConfirmedTransactionsRequest {
	return ApiSearchConfirmedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionPage
func (a *TransactionRoutesAPIService) SearchConfirmedTransactionsExecute(r ApiSearchConfirmedTransactionsRequest) (*TransactionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.SearchConfirmedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/confirmed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "")
	}
	if r.recipientAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipientAddress", r.recipientAddress, "")
	}
	if r.signerPublicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signerPublicKey", r.signerPublicKey, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	}
	if r.fromHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromHeight", r.fromHeight, "")
	}
	if r.toHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toHeight", r.toHeight, "")
	}
	if r.fromTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTransferAmount", r.fromTransferAmount, "")
	}
	if r.toTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTransferAmount", r.toTransferAmount, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.embedded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedded", r.embedded, "")
	} else {
		var defaultValue bool = false
		r.embedded = &defaultValue
	}
	if r.transferMosaicId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferMosaicId", r.transferMosaicId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue Order = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPartialTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	address *string
	recipientAddress *string
	signerPublicKey *string
	height *string
	fromHeight *string
	toHeight *string
	fromTransferAmount *string
	toTransferAmount *string
	type_ *[]TransactionTypeEnum
	embedded *bool
	transferMosaicId *string
	pageSize *int32
	pageNumber *int32
	offset *string
	order *Order
}

// Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
func (r ApiSearchPartialTransactionsRequest) Address(address string) ApiSearchPartialTransactionsRequest {
	r.address = &address
	return r
}

// Filter by address of the account receiving the transaction.
func (r ApiSearchPartialTransactionsRequest) RecipientAddress(recipientAddress string) ApiSearchPartialTransactionsRequest {
	r.recipientAddress = &recipientAddress
	return r
}

// Filter by public key of the account signing the entity.
func (r ApiSearchPartialTransactionsRequest) SignerPublicKey(signerPublicKey string) ApiSearchPartialTransactionsRequest {
	r.signerPublicKey = &signerPublicKey
	return r
}

// Filter by block height.
func (r ApiSearchPartialTransactionsRequest) Height(height string) ApiSearchPartialTransactionsRequest {
	r.height = &height
	return r
}

// Only blocks with height greater or equal than this one are returned.
func (r ApiSearchPartialTransactionsRequest) FromHeight(fromHeight string) ApiSearchPartialTransactionsRequest {
	r.fromHeight = &fromHeight
	return r
}

// Only blocks with height smaller or equal than this one are returned.
func (r ApiSearchPartialTransactionsRequest) ToHeight(toHeight string) ApiSearchPartialTransactionsRequest {
	r.toHeight = &toHeight
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
func (r ApiSearchPartialTransactionsRequest) FromTransferAmount(fromTransferAmount string) ApiSearchPartialTransactionsRequest {
	r.fromTransferAmount = &fromTransferAmount
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
func (r ApiSearchPartialTransactionsRequest) ToTransferAmount(toTransferAmount string) ApiSearchPartialTransactionsRequest {
	r.toTransferAmount = &toTransferAmount
	return r
}

// Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
func (r ApiSearchPartialTransactionsRequest) Type_(type_ []TransactionTypeEnum) ApiSearchPartialTransactionsRequest {
	r.type_ = &type_
	return r
}

// When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
func (r ApiSearchPartialTransactionsRequest) Embedded(embedded bool) ApiSearchPartialTransactionsRequest {
	r.embedded = &embedded
	return r
}

// Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
func (r ApiSearchPartialTransactionsRequest) TransferMosaicId(transferMosaicId string) ApiSearchPartialTransactionsRequest {
	r.transferMosaicId = &transferMosaicId
	return r
}

// Select the number of entries to return.
func (r ApiSearchPartialTransactionsRequest) PageSize(pageSize int32) ApiSearchPartialTransactionsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by page number.
func (r ApiSearchPartialTransactionsRequest) PageNumber(pageNumber int32) ApiSearchPartialTransactionsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
func (r ApiSearchPartialTransactionsRequest) Offset(offset string) ApiSearchPartialTransactionsRequest {
	r.offset = &offset
	return r
}

// Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
func (r ApiSearchPartialTransactionsRequest) Order(order Order) ApiSearchPartialTransactionsRequest {
	r.order = &order
	return r
}

func (r ApiSearchPartialTransactionsRequest) Execute() (*TransactionPage, *http.Response, error) {
	return r.ApiService.SearchPartialTransactionsExecute(r)
}

/*
SearchPartialTransactions Search partial transactions

Returns an array of partial transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPartialTransactionsRequest
*/
func (a *TransactionRoutesAPIService) SearchPartialTransactions(ctx context.Context) ApiSearchPartialTransactionsRequest {
	return ApiSearchPartialTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionPage
func (a *TransactionRoutesAPIService) SearchPartialTransactionsExecute(r ApiSearchPartialTransactionsRequest) (*TransactionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.SearchPartialTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/partial"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "")
	}
	if r.recipientAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipientAddress", r.recipientAddress, "")
	}
	if r.signerPublicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signerPublicKey", r.signerPublicKey, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	}
	if r.fromHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromHeight", r.fromHeight, "")
	}
	if r.toHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toHeight", r.toHeight, "")
	}
	if r.fromTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTransferAmount", r.fromTransferAmount, "")
	}
	if r.toTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTransferAmount", r.toTransferAmount, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.embedded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedded", r.embedded, "")
	} else {
		var defaultValue bool = false
		r.embedded = &defaultValue
	}
	if r.transferMosaicId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferMosaicId", r.transferMosaicId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue Order = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchUnconfirmedTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionRoutesAPIService
	address *string
	recipientAddress *string
	signerPublicKey *string
	height *string
	fromHeight *string
	toHeight *string
	fromTransferAmount *string
	toTransferAmount *string
	type_ *[]TransactionTypeEnum
	embedded *bool
	transferMosaicId *string
	pageSize *int32
	pageNumber *int32
	offset *string
	order *Order
}

// Filter by address involved in the transaction. An account&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
func (r ApiSearchUnconfirmedTransactionsRequest) Address(address string) ApiSearchUnconfirmedTransactionsRequest {
	r.address = &address
	return r
}

// Filter by address of the account receiving the transaction.
func (r ApiSearchUnconfirmedTransactionsRequest) RecipientAddress(recipientAddress string) ApiSearchUnconfirmedTransactionsRequest {
	r.recipientAddress = &recipientAddress
	return r
}

// Filter by public key of the account signing the entity.
func (r ApiSearchUnconfirmedTransactionsRequest) SignerPublicKey(signerPublicKey string) ApiSearchUnconfirmedTransactionsRequest {
	r.signerPublicKey = &signerPublicKey
	return r
}

// Filter by block height.
func (r ApiSearchUnconfirmedTransactionsRequest) Height(height string) ApiSearchUnconfirmedTransactionsRequest {
	r.height = &height
	return r
}

// Only blocks with height greater or equal than this one are returned.
func (r ApiSearchUnconfirmedTransactionsRequest) FromHeight(fromHeight string) ApiSearchUnconfirmedTransactionsRequest {
	r.fromHeight = &fromHeight
	return r
}

// Only blocks with height smaller or equal than this one are returned.
func (r ApiSearchUnconfirmedTransactionsRequest) ToHeight(toHeight string) ApiSearchUnconfirmedTransactionsRequest {
	r.toHeight = &toHeight
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
func (r ApiSearchUnconfirmedTransactionsRequest) FromTransferAmount(fromTransferAmount string) ApiSearchUnconfirmedTransactionsRequest {
	r.fromTransferAmount = &fromTransferAmount
	return r
}

// Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
func (r ApiSearchUnconfirmedTransactionsRequest) ToTransferAmount(toTransferAmount string) ApiSearchUnconfirmedTransactionsRequest {
	r.toTransferAmount = &toTransferAmount
	return r
}

// Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
func (r ApiSearchUnconfirmedTransactionsRequest) Type_(type_ []TransactionTypeEnum) ApiSearchUnconfirmedTransactionsRequest {
	r.type_ = &type_
	return r
}

// When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
func (r ApiSearchUnconfirmedTransactionsRequest) Embedded(embedded bool) ApiSearchUnconfirmedTransactionsRequest {
	r.embedded = &embedded
	return r
}

// Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
func (r ApiSearchUnconfirmedTransactionsRequest) TransferMosaicId(transferMosaicId string) ApiSearchUnconfirmedTransactionsRequest {
	r.transferMosaicId = &transferMosaicId
	return r
}

// Select the number of entries to return.
func (r ApiSearchUnconfirmedTransactionsRequest) PageSize(pageSize int32) ApiSearchUnconfirmedTransactionsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter by page number.
func (r ApiSearchUnconfirmedTransactionsRequest) PageNumber(pageNumber int32) ApiSearchUnconfirmedTransactionsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
func (r ApiSearchUnconfirmedTransactionsRequest) Offset(offset string) ApiSearchUnconfirmedTransactionsRequest {
	r.offset = &offset
	return r
}

// Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
func (r ApiSearchUnconfirmedTransactionsRequest) Order(order Order) ApiSearchUnconfirmedTransactionsRequest {
	r.order = &order
	return r
}

func (r ApiSearchUnconfirmedTransactionsRequest) Execute() (*TransactionPage, *http.Response, error) {
	return r.ApiService.SearchUnconfirmedTransactionsExecute(r)
}

/*
SearchUnconfirmedTransactions Search unconfirmed transactions

Returns an array of unconfirmed transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchUnconfirmedTransactionsRequest
*/
func (a *TransactionRoutesAPIService) SearchUnconfirmedTransactions(ctx context.Context) ApiSearchUnconfirmedTransactionsRequest {
	return ApiSearchUnconfirmedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionPage
func (a *TransactionRoutesAPIService) SearchUnconfirmedTransactionsExecute(r ApiSearchUnconfirmedTransactionsRequest) (*TransactionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRoutesAPIService.SearchUnconfirmedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/unconfirmed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "")
	}
	if r.recipientAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipientAddress", r.recipientAddress, "")
	}
	if r.signerPublicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signerPublicKey", r.signerPublicKey, "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "")
	}
	if r.fromHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromHeight", r.fromHeight, "")
	}
	if r.toHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toHeight", r.toHeight, "")
	}
	if r.fromTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTransferAmount", r.fromTransferAmount, "")
	}
	if r.toTransferAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTransferAmount", r.toTransferAmount, "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.embedded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embedded", r.embedded, "")
	} else {
		var defaultValue bool = false
		r.embedded = &defaultValue
	}
	if r.transferMosaicId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferMosaicId", r.transferMosaicId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 10
		r.pageSize = &defaultValue
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue Order = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
